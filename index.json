[{"categories":["心得"],"contents":"Char Device Kernel設備驅動程式是將底層硬體公開給系統其餘部分的機制。\n作為嵌入式系統的開發者，您需要了解這些設備驅動程式如何適合整體架構，以及如何從用戶空間程式中訪問它們。\n您的系統可能會有一些新奇的硬體組件，您需要找到一種方法來訪問它們。\n在許多情況下，您會發現已經為您提供了一些設備驅動程式，您可以在不編寫任何Kernel代碼的情況下實現所需的一切。\n例如，您可以使用 sysfs 中的文件來操作 GPIO 引腳和 LED，並且有庫可以訪問串行匯流排，包括 SPI（串行週邊介面）和 I2C（雙線串行匯流排）。\n字符設備（Character Device）適用於 **非緩衝的輸入/輸出(unbuffered I/O) 操作，提供了多種豐富的功能，並在應用程式代碼和驅動程式之間保持了簡潔的界面。當您需要實現自訂的設備驅動程式時，這通常是首選方案。換句話說，它能夠讓您的應用程式直接和硬體互動，而不需要太多繁雜的中間步驟。(這裡的\u0026quot;中間步驟\u0026quot;是指介於應用程式和驅動程式之間的額外操作、轉換或處理，這可能會增加代碼的複雜性和執行時間。)\n例如，您可能會通過 /sys/class/gpio 目錄下的一組文件來訪問 GPIO 驅動程式。\n字符設備在用戶空間中通過稱為設備節點的特殊文件來識別。這個文件名通過主要和次要編號來映射到設備驅動程式。主要編號將設備節點映射到特定的驅動程式，次要編號則告訴驅動程式訪問的介面。\n例如，在 ARM Versatile PB 上，\n第一個串口的設備節點是 /dev/ttyAMA0，\n它的主要編號是 204，次要編號是 64。\n第二個串口的設備節點有相同的主要編號，但次要編號是 65。這些編號可以從目錄清單中看到。\n# ls -l /dev/ttyAMA*\rcrw-rw---- 1 root root 204, 64 Jan 1 1970 /dev/ttyAMA0\rcrw-rw---- 1 root root 204, 65 Jan 1 1970 /dev/ttyAMA1\rcrw-rw---- 1 root root 204, 66 Jan 1 1970 /dev/ttyAMA2\rcrw-rw---- 1 root root 204, 67 Jan 1 1970 /dev/ttyAMA3 標準的主要（major number） 和次要（minor number）編號清單可以在Linux Kernel文檔中的 Documentation/devices.txt 找到。該清單不會經常更新，且不包含前面段落中描述的 ttyAMA 設備。然而，如果您查看位於 drivers/tty/serial/amba-pl011.c 的Kernel源代碼，您將看到major number和minor number的define：\n#define SERIAL_AMBA_MAJOR 204\r#define SERIAL_AMBA_MINOR 64 這些聲明指定了特定設備（例如 ttyAMA）的major number和minor number，以便Kernel和應用程式可以識別和訪問這些設備。雖然該標準清單可能不包含所有設備，但它提供了一個參考，供開發者了解如何設定major number和minor number以進行設備識別。\n當存在多個同類型的設備實例時，例如 ttyAMA 驅動程式，形成設備節點名稱的慣例是採用基本名稱 ttyAMA，然後在這個例子中從 0 到 3 添加實例編號。\n我的raspberry pi 如下\rroot@raspberrypi:~# ls -l /dev/ttyAMA*\rcrw-rw---- 1 root dialout 204, 64 Aug 5 10:38 /dev/ttyAMA0 P.S. 在一些系統中，特別是像 Linux 等操作系統中，串口（UART）設備的命名可能會類似於 ttyS0、ttyS1 等。不同的系統和設備可能會有不同的命名慣例。 在 Raspberry Pi 上，UART 串口的命名通常是 ttyAMA0。但是，如果您使用的是較新的 Raspberry Pi 版本，例如 Raspberry Pi 3 或更高版本，可能會使用 ttyS0 來表示第一個 UART 串口。\nlinux 裝置管理員 有以下這麼多種:\ndevtmpfs：當設備驅動程式使用由驅動程式提供的基本名稱（例如 ttyAMA）和實例編號註冊新的設備介面時，設備節點將被創建。\nudev 或 mdev（不使用 devtmpfs）：與使用 devtmpfs 基本相同，不同之處在於需要使用用戶空間的守護程序從 sysfs 中提取設備名稱並創建節點。稍後我會談到 sysfs。\nmknod：如果您正在使用靜態設備節點，則可以使用 mknod 手動創建它們。\nmajor number已經擴展為12位元，有效的編號範圍從1到4,095，而minor number則擴展為20位元，範圍從0到1,048,575。\n當你打開一個字符設備節點時，內核會檢查主要和次要編號是否落在由字符設備驅動程式註冊的範圍內。如果是，它會將呼叫傳遞給驅動程式，否則打開呼叫將失敗。設備驅動程式可以提取次要編號，以了解要使用哪個硬體介面。\n所以 major number + minor number = 32個位元\n假設你有個應用程式(Application)如下，一個簡單的例子是虛擬隨機數發生器 urandom，每次讀取它時會返回隨機數據的位元組:\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int main(void) { int f; unsigned int rnd; int n; f = open(\u0026#34;/dev/urandom\u0026#34;, O_RDONLY); if (f \u0026lt; 0) { perror(\u0026#34;Failed to open urandom\u0026#34;); return 1; } n = read(f, \u0026amp;rnd, sizeof(rnd)); if (n != sizeof(rnd)) { perror(\u0026#34;Problem reading urandom\u0026#34;); return 1; } printf(\u0026#34;Random number = 0x%x\\n\u0026#34;, rnd); close(f); return 0; } 我的RPI如下:\n/dev/urandom 不是一個真的硬體，但軟體RD 喜歡這樣，把東西都給虛擬化、抽象化。\nFinding out about drivers at runtime 一旦您運行了 Linux 系統，了解已加載的設備驅動程式以及它們的狀態將非常有用。您可以通過讀取 /proc 和 /sys 目錄中的文件來獲得許多信息。\n# cat /proc/devices\rCharacter devices:\r1 mem\r4 /dev/vc/0\r4 tty\r4 ttyS\r5 /dev/tty\r5 /dev/console\r5 /dev/ptmx\r5 ttyprintk\r7 vcs\r10 misc\r13 input\r14 sound\r29 fb\r81 video4linux\r116 alsa\r128 ptm\r136 pts\r180 usb\r189 usb_device\r204 ttyAMA\r226 drm\r240 cec\r241 media\r242 uio\r243 hidraw\r244 rpmb\r245 bcm2835-gpiomem\r246 vc-mem\r247 bsg\r248 watchdog\r249 ptp\r250 pps\r251 lirc\r252 rtc\r253 dma_heap\r254 gpiochip\rBlock devices:\r1 ramdisk\r7 loop\r8 sd\r65 sd\r66 sd\r67 sd\r68 sd\r69 sd\r70 sd\r71 sd\r128 sd\r129 sd\r130 sd\r131 sd\r132 sd\r133 sd\r134 sd\r135 sd\r179 mmc\r259 blkext\r/proc 是告訴我，目前那些東西已經啟動\rroot@raspberrypi:~# cd /proc/\rroot@raspberrypi:/proc# ls\r1 208 281 405 522 684 cgroups key-users swaps\r10 209 285 41 53 688 cmdline kmsg sys\r100 210 289 42 553 690 consoles kpagecgroup sysrq-trigger\r11 211 29 420 554 741 cpu kpagecount sysvipc\r112 212 3 421 567 743 cpuinfo kpageflags thread-self\r114 213 32 43 58 744 crypto latency_stats timer_list\r12 214 33 44 59 746 devices loadavg tty\r13 22 35 451 591 749 device-tree locks uptime\r138 23 36 452 6 88 diskstats meminfo version\r14 24 360 456 60 89 driver misc vmallocinfo\r146 253 362 464 61 90 execdomains modules vmstat\r15 256 363 465 613 91 fb mounts zoneinfo\r16 257 37 482 62 92 filesystems net\r165 27 372 485 63 93 fs pagetypeinfo\r17 272 378 5 633 95 interrupts partitions\r178 273 38 50 64 96 iomem schedstat\r179 277 385 502 65 97 ioports self\r18 279 39 51 656 asound irq slabinfo\r19 28 4 516 66 buddyinfo kallsyms softirqs\r2 280 40 52 683 bus keys stat Getting information from sysfs 新的driver 都希望在/sys 產生節點 您可以將 sysfs 在嚴格的定義中看作是內核對象、屬性和關係的表示。內核對象是一個目錄，屬性是一個文件，而關係則是從一個對象到另一個對象的符號連結。從一個更實際的角度來看，由於 Linux 設備驅動程式模型將所有設備和驅動程式都表示為內核對象，您可以透過查看 /sys 來看到內核對系統的視圖，如下所示：\nroot@raspberrypi:/proc# ls /sys/class\rbacklight extcon iscsi_iface pps spi_master\rbcm2835-gpiomem gpio iscsi_session ptp spi_slave\rbdi graphics iscsi_transport pwm thermal\rblock hidraw leds rc tty\rbluetooth hwmon lirc regulator udc\rbsg i2c-adapter mdio_bus rfkill uio\rdevcoredump ieee80211 mem rtc vc\rdevlink input misc scsi_device vc-mem\rdma iscsi_connection mmc_host scsi_disk video4linux\rdma_heap iscsi_endpoint net scsi_host vtconsole\rdrm iscsi_host power_supply sound watchdog\rroot@raspberrypi:/proc# ls /dev\rautofs loop4 ram2 tty17 tty41 tty9 vcsu1\rblock loop5 ram3 tty18 tty42 ttyAMA0 vcsu2\rbtrfs-control loop6 ram4 tty19 tty43 ttyprintk vcsu3\rbus loop7 ram5 tty2 tty44 ttyS0 vcsu4\rcachefiles loop-control ram6 tty20 tty45 uhid vcsu5\rcec0 mapper ram7 tty21 tty46 uinput vcsu6\rchar media0 ram8 tty22 tty47 urandom vhci\rconsole media1 ram9 tty23 tty48 v4l video10\rcuse media2 random tty24 tty49 vchiq video11\rdisk mem rfkill tty25 tty5 vcio video12\rdma_heap mmcblk0 serial0 tty26 tty50 vc-mem video13\rdri mmcblk0p1 serial1 tty27 tty51 vcs video14\rfd mmcblk0p2 shm tty28 tty52 vcs1 video15\rfull mqueue snd tty29 tty53 vcs2 video16\rfuse net stderr tty3 tty54 vcs3 video18\rgpiochip0 null stdin tty30 tty55 vcs4 video20\rgpiochip1 ppp stdout tty31 tty56 vcs5 video21\rgpiomem ptmx tty tty32 tty57 vcs6 video22\rhwrng pts tty0 tty33 tty58 vcsa video23\rinitctl ram0 tty1 tty34 tty59 vcsa1 video31\rinput ram1 tty10 tty35 tty6 vcsa2 watchdog\rkmsg ram10 tty11 tty36 tty60 vcsa3 watchdog0\rlog ram11 tty12 tty37 tty61 vcsa4 zero\rloop0 ram12 tty13 tty38 tty62 vcsa5\rloop1 ram13 tty14 tty39 tty63 vcsa6\rloop2 ram14 tty15 tty4 tty7 vcsm-cma\rloop3 ram15 tty16 tty40 tty8 vcsu\rroot@raspberrypi:/proc# cd ~\rroot@raspberrypi:~# ls /sys/class/tty/ttyAMA0\rclose_delay dev iomem_base line type\rclosing_wait device iomem_reg_shift port uartclk\rconsole flags io_type power uevent\rcustom_divisor hci0 irq subsystem xmit_fifo_size\rroot@raspberrypi:~# cat /sys/class/tty/ttyAMA0/dev\r204:64 都希望在class 下產生，SW RD 想要抽象化，希望使用者，可以直接透過class 存取到device就好，不用直接去改到driver code。\n在 make menuconfig 放入自己寫的Driver 注意環境變數 這邊以raspberry pi3 為例\n$ sudo apt install bc bison crossbuild-essential-armhf flex git libc6-dev libncurses5-dev libssl-dev\r$ export ARCH=arm\r$ export KERNEL=kernel7\r$ export CROSS_COMPILE=arm-linux-gnueabihf-\r$ git clone --depth=1 https://github.com/raspberrypi/linux\r$ cd linux\r$ make bcm2709_defconfig 在linux/drivers/char 下放入driver source code ，假設是hello 如下圖所示: //main.c #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/init.h\u0026gt; MODULE_LICENSE(\u0026#34;Dual BSD/GPL\u0026#34;); extern void sub(void); static int hello_init(void) { printk(KERN_ALERT \u0026#34;driver loaded\\n\u0026#34;); sub(); return 0; } static void hello_exit(void) { printk(KERN_ALERT \u0026#34;driver unloaded\\n\u0026#34;); } module_init(hello_init); module_exit(hello_exit); //sub.c #include \u0026lt;linux/module.h\u0026gt; #include \u0026lt;linux/init.h\u0026gt; void sub(void) { printk(\u0026#34;%s: sub() called\\n\u0026#34;, __func__); } Makefile :\nobj-$(CONFIG_HELLO) += hello.o\rhello-objs\t:= main.o sub.o 在 hello 上層，也就是char 這層更改 Kconfig 和 Makefile Make menuconfig 可以 M module選取，然後make 獨立編譯.ko的方式，以 MA35D1 為例 # export PATH=$PATH:/home/user/buildroot/MA35D1_Buildroot/output/host/bin\rPWD := $(shell pwd)\rKDIR = /home/user/buildroot/MA35D1_Buildroot/output/build/linux-custom\robj-m += mymodule.o\rmymodule-objs := main.o sub.o\rARCH ?= arm64\rCROSS_COMPILE ?= aarch64-linux-\rall drivers:\rmake -C $(KDIR) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) M=$(PWD) modules\rclean:\rmake -C $(KDIR) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) M=$(PWD) clean 一個ioctl的範例 下載看\u0026hellip;..\n","permalink":"https://weizongchen.github.io/blog/ldd_brief_intro/","tags":["raspberry pi","linux"],"title":"簡單說明Linux驅動程式"},{"categories":["安裝步驟文件"],"contents":" opennuvoton N9H30 https://github.com/OpenNuvoton/MPU-Family\nStart up with VMware This VMware Image offers a Linux development environment for N9H30.\nopennuvoton 的 VM 檔案 : N9H30 VMware\nUser Name: nuvoton\nPassword: user\nDownload and Update Buildroot Open Terminal and path to the NUC970_Buildroot folder:\n$ cd NUC970_Buildroot Update the buildroot:\n/NUC970_Buildroot$ git pull Set configuration to the target board\n$ make nuvoton_n9h30_emwin_defconfig Build image\n$ make Building Finishing Once the build is complete, you can find the resulting image at /output/image\nNeed the u-boot.bin and uImage files to program the N9H30 EVB through NuWriter. Image: Linux kernel image used for running on DDR\nuImage: Linux kernel image used for booting with uboot\nu-boot.bin: uboot image\nu-boot-spl.bin: “uboot Secondary Program Loader image”, used for booting from SPI NAND\n(~/output/build/uboot-master/spl/u-boot-spl.bin)\nIf you made a minor change, you can use the following: To configure Buildroot:\n$ make menuconfig To configure uboot:\n$ make uboot-menuconfig To configure kernel:\n$ make linux-menuconfig make\n$ make –j4 Rebuild the uboot\n$ make uboot-rebuild \u0026amp;\u0026amp; make Rebuild the kernel\n$ make linux-rebuild \u0026amp;\u0026amp; make Clean directory project (Ex)\n$ make \u0026lt;package\u0026gt;-dirclean Clean up any previously built files, you can use the following commands:​\n$ make clean Programming Usually, you would use NuWriter for N9H30 to program the image.\nInstall WinUSB4NuVCOM Driver\nOpen NUC970_NuWriter-master\\NuWriter\\NuWriter\\Release\nSelect the corresponding IC model. N9H30F61IEC.ini\nEvaluation Board Introduction Debug Port (console): show the debug message USB Device: used to program image by NuWriter Power-On Switch: Switch booting source Reset Button: reset N9H30 To program an image to N9H30 EVB, set the Power-o-setting to USB mode and connect it to the PC S0 and S1 are High 按下Reset後，在按tool的connect Click the Reset button and you will see the debug message: “Boot from USB”. RAM: DDR/SRAM : Non-permanent data storage for debugging External storage : NAND SPI-Flash Env.txt Kernel Size 重點說明\nstderr=serial, stdin=serial, stdout=serial： 這些參數設置了標準輸入（stdin）、標準輸出（stdout）和標準錯誤（stderr）的輸出位置。\n在這裡，它們都被設定為串列（serial）介面，這意味著系統將使用串列通訊埠來進行輸入和輸出。\nloadkernel=nand read 0x7fc0 0x200000 0x800000： 此參數是一個自定義的指令，用於從 NAND 快閃記憶體中讀取核心映像並載入到記憶體中。\n具體來說：\nnand read: 這個指令表示從 NAND 快閃記憶體中讀取資料。\n0x7fc0: 是載入核心映像的目標記憶體位址。\n0x200000: 是從 NAND 記憶體中讀取資料的位址偏移量。\n0x800000: 是要讀取的字節數（此處為 8MB）。\nFILE SYSTEM YAFFS Create YAFFS Format Root Filesystem on NAND 1.1 Setting up the development enviromnet.\nPlease donwload the necessary package for development.\n$ sudo apt install git make g++ python nucurses5-dev meas-common-dev libglu1-mesa-dev Download the N9H30 Source code\n$ git clone https://github.com/OpenNuvoton/NUC970_Buildroot.git NUC970_Buildroot_N9H30 1.2 Configuration options for the N9H30 system.\nSetup default configuration of N9H30\n$ make nuvoton_n9h30_emwin_defconfig Build default image and related configurations.\n$ make -j8 1.3 Configuration options for NAND flash setting options.\nBuildroot\n$ make menuconfig Linux kernal\n$ make linux-menuconfig $ make linux-rebuild\r$ make -j8 Modify u-boot env.txt env.txt is a u-boot environment variable file. u-boot can read data to RAM from Flash, boot kernel from RAM.\nThe variable bootcmd will be executed when u-boot starts and the variable bootdelay has been defined.\nThe following command will read the kernel image from Flash to RAM and boot from RAM address 7fc0.\nenv.txt 是一個 u-boot 環境變數文件。u-boot 可以從 Flash 讀取數據到 RAM，然後從 RAM 啟動內核。\n當 u-boot 啟動並且已經定義了變數 bootdelay 時，變數 bootcmd 將被執行。\n以下命令將從 Flash 讀取內核映像到 RAM，然後從 RAM 地址 0x7fc0 開始啟動\nloadkernel=nand read 0x7fc0 0x200000 0x600000\rbootcmd=run loadkernel;bootm 0x7fc0 u-boot can use MTD to partition Flash into three mtdblocks and create YAFFS2 format root filesystem on mtdblock2.\nThe Flash address and size below can be changed to anywhere you want.\nu-boot 可以使用 MTD（Memory Technology Device）將 Flash 劃分為三個 mtdblocks（區塊），並在 mtdblock2 上創建 YAFFS2 格式的根文件系統。\n下面的 Flash 地址和大小可以根據需要進行更改。\nmtdblock0 stores u-boot image and its Flash offset is from 0x0 to 0x200000. mtdblock1 stores kernel image and its Flash offset is from 0x200000 to 0x800000. mtdblock2 stores root filesystem image and its Flash offset is from 0x800000 to the end. 這些信息說明了 Flash 存儲中的三個 mtdblocks 的配置：\nmtdblock0 存儲 u-boot 映像，其 Flash 偏移從 0x0 到 0x200000。 mtdblock1 存儲內核映像，其 Flash 偏移從 0x200000 到 0x800000。 mtdblock2 存儲根文件系統映像，其 Flash 偏移從 0x800000 到 Flash 的結尾。 每個 mtdblock 都是 Flash 存儲中的一個連續區塊，用於存儲特定的數據，如 u-boot 映像、內核映像和根文件系統映像。Flash 偏移指的是 Flash 存儲中的起始位置，並以十六進制地址表示。 這種配置可讓 u-boot 和其他系統元件能夠輕鬆地從 Flash 存儲區讀取所需的映像，並在系統啟動過程中使用它們。這種分區和映像的組織方式有助於確保系統的順利運行，同時也方便了升級和維護。\nThe whole env.txt content is shown below: baudrate=115200\rbootdelay=1\rstderr=serial\rstdin=serial\rstdout=serial\rloadkernel=nand read 0x7fc0 0x200000 0x600000\rbootcmd=run loadkernel;bootm 7fc0\rbootargs=noinitrd root=/dev/mtdblock2 rootfstype=yaffs2 rootflags=inband-tags\rconsole=ttyS0 rdinit=/sbin/init mem=64M\rmtdparts=nand0:0x200000@0x0(u-boot),0x600000@0x200000(kernel),-(user) ignore_loglevel Program Image to Evaluation Board Program the following Image files to the target board. Each image has particular address and these addresses depend on\nenv.txt.\nImage Name Image Type Address u-boot-spl.bin uboot 0x200 env.txt Env 0x80000 u-boot.bin Data 0x100000 uImage Data 0x200000 rootfs.yaffs2 Data 0x800000 Check Root Filesystem Please enter the following command in the terminal of the N9H30 system.\n# dmesg | grep yaffs Kernel command line: noinitrd root=/dev/mtdblock2 rootfstype=yaffs2 rootflags=inband-tags console=ttyS0\rrdinit=/sbin/init mem=64M\rmtdparts=nand0:0x200000@0x0(u-boot),0x600000@0x200000(kernel),-(user) ignore_loglevel\ryaffs: yaffs built Apr 6 2023 13:10:23 Installing.\ryaffs: dev is 32505858 name is \u0026#34;mtdblock2\u0026#34; rw\ryaffs: passed flags \u0026#34;inband-tags\u0026#34;\ryaffs: yaffs: Attempting MTD mount of 31.2,\u0026#34;mtdblock2\u0026#34;\ryaffs: block 957 is bad\ryaffs: block 958 is bad\ryaffs: block 959 is bad\ryaffs: block 960 is bad\ryaffs: 129 blocks to be sorted...\ryaffs: yaffs_read_super: is_checkpointed 0\rVFS: Mounted root (yaffs2 filesystem) on device 31:2. FILE SYSTEM JFFS2 Create JFFS2 Format Root Filesystem on NOR Flash Modify Buildroot Configuration Buildroot$ make menuconfig Cancel the default configuration that creates root file system on RAM.\nCancel cpio the root filesytem(for use as an initial RAM filesytem)\nCancel initial RAM filesytem linked into linux kernel\nUse JFFS2 root filesytem.\nSeparate Linux kernel and root filesytem from uImage and tar the root filesystem with JFFS2 Format.\nChoose Flash Type to Parallel Flash with 128KB erase size.\nModify Linux Kernel configuration ~Buildroot$ make linux-menuconfig Cancel RAM filesystem and RAM disk support.\nCancel Initial RAM filesystem and RAM disk (initramfs/initrd) support.\nUse MTD partition command in u-boot.\nTick command line partition table parsing.\nTick caching block device access to MTD devices.\nUse SPI support\nTick Nuvoton NUC970/N9H30 Series SPI Port 0.\nEnsure that Linux kernel supports JFFS2 format:\nTick Journalling Flash File System v2 (JFFS2) support to open JFSS2 options.\nTick JFFS2 summary support\nTick JFFS2 XATTR support\nTick JFFS2 Security Labels\nModify mtdblock Auto Mount Some particular evaluation boards have \u0026ldquo;mdev\u0026rdquo; file determining which mtdblock will be auto mounted.\nYou can check if the path board/nuvoton/rootfs-xxx/etc has \u0026ldquo;mdev\u0026rdquo; file or not.\nThe default setting is auto mount mtdblock1 to mtdblock9.\nIn other words, it will mount u-boot and Linux kernel and will cause error.\nTo avoid this problem, modify \u0026ldquo;mdev\u0026rdquo; file with the following step. This demo is operated on\n~Buildroot$ vim board/nuvoton/rootfs-xxx/etc/mdev.conf Modify the source code below:\nmtdblock([3-9]+) 0:0 660 */sbin/automount.sh $MDEV X${ACTION} 一些特定的評估板使用 \u0026ldquo;mdev\u0026rdquo; 文件來確定將自動掛載哪個 mtdblock。您可以檢查路徑 board/nuvoton/rootfs-xxx/etc 是否具有 \u0026ldquo;mdev\u0026rdquo; 文件。\n默認設置是自動掛載 mtdblock1 到 mtdblock9。換句話說，這將掛載 u-boot 和 Linux 內核，並導致錯誤。\n為了避免這個問題，請按照以下步驟修改 \u0026ldquo;mdev\u0026rdquo; 文件。\nModify JFFS2 Erase Size The rootfs_jffs2 image cannot be directly programed into an evaluation board. Thus, you can use mkfs tool to generate jffs2.img.\nBecause JFFS2 format needs the minimum erase size of 8k, you should modify setting in Linux driver.\nModify output/build/linux-master/drivers/mtd/devices/m25p80.c /* Winbond -- w25x \u0026#34;blocks\u0026#34; are 64K, \u0026#34;sectors\u0026#34; are 4KiB */\r{ \u0026#34;w25x10\u0026#34;, INFO(0xef3011, 0, 64 * 1024, 2, SECT_4K) },\r{ \u0026#34;w25x20\u0026#34;, INFO(0xef3012, 0, 64 * 1024, 4, SECT_4K) },\r{ \u0026#34;w25x40\u0026#34;, INFO(0xef3013, 0, 64 * 1024, 8, SECT_4K) },\r{ \u0026#34;w25x80\u0026#34;, INFO(0xef3014, 0, 64 * 1024, 16, SECT_4K) },\r{ \u0026#34;w25x16\u0026#34;, INFO(0xef3015, 0, 64 * 1024, 32, SECT_4K) },\r{ \u0026#34;w25x32\u0026#34;, INFO(0xef3016, 0, 64 * 1024, 64, SECT_4K) },\r{ \u0026#34;w25q32\u0026#34;, INFO(0xef4016, 0, 64 * 1024, 64, SECT_4K) },\r{ \u0026#34;w25q32dw\u0026#34;, INFO(0xef6016, 0, 64 * 1024, 64, SECT_4K) },\r{ \u0026#34;w25x64\u0026#34;, INFO(0xef3017, 0, 64 * 1024, 128, SECT_4K) },\r{ \u0026#34;w25q64\u0026#34;, INFO(0xef4017, 0, 64 * 1024, 128, SECT_4K) },\r{ \u0026#34;w25q80\u0026#34;, INFO(0xef5014, 0, 64 * 1024, 16, SECT_4K) },\r{ \u0026#34;w25q80bl\u0026#34;, INFO(0xef4014, 0, 64 * 1024, 16, SECT_4K) },\r{ \u0026#34;w25q128\u0026#34;, INFO(0xef4018, 0, 64 * 1024, 256, SECT_4K | M25P80_DUAL_READ | M25P80_QUAD_READ | M25P80_QUAD_WRI\r/* { \u0026#34;w25q256\u0026#34;, INFO(0xef4019, 0, 64 * 1024, 512, SECT_4K) }, */\r{ \u0026#34;w25q256\u0026#34;, INFO(0xef4019, 0, 64 * 1024, 512, 0) },\r{ \u0026#34;w25q256jvim\u0026#34;, INFO(0xef7019, 0, 64 * 1024, 512, SECT_4K) },\r{ \u0026#34;w25q512jvf\u0026#34;, INFO(0xef4020, 0, 64 * 1024, 1024, SECT_4K) }, ~Buildroot$ make linux-rebuild Modify uboot configuration Follw the steps below to modify Buildrot configuration.\n~Buildroot$ cd output/build/uboot-master/\r~Buildroot/output/build/uboot-master/$ make menuconfig Use SPI support Tick NUC970/N9H30 SPI driver and select NUC970/N9H30 SPI in Quad mode\nEnable the legacy SPI flash support. This will include basic standard support for things like probing, read / write, and erasing through cmd_sf interface. Tick SPI flash Bank/Extended address register support. This opetion is used to access the flash which has size \u0026gt; 16 MiB in 3-byte addresing.\nTick Winbond SPI flash. Because N9H30 evb just used Winboad flash.\nDevice access commands Tick sf command.\nTick sspi command.\nModify include/configs/nuc970_evb.h #define CONFIG_SYS_USE_SPIFLASH\r#define CONFIG_SYS_USE_NANDFLASH\r/*#define CONFIG_ENV_IS_IN_NAND */\r#define CONFIG_ENV_IS_IN_SPI_FLASH\r/*#define CONFIG_ENV_IS_IN_MMC */ ~Buildroot/output/build/uboot-master/$ cd -\r~Buildroot$ make uboot-rebuild\r~Buildroot$ make Use mkfs Tool to Generate Root Filesystem Image After installing successfully and compiling Linux kernel, go to Image folder. Create rootfs folder to unzip rootfs.tar.\n~Buildroot$ cd output/images\r~Buildroot/output/images$ mkdir rootfs\r~Buildroot/output/images$ sudo tar -C ./rootfs -xf rootfs.tar Use mkfs to generate jffs2.img\n~Buildroot/output/images$ sudo mkfs.jffs2 -s 0x1000 -e 0x10000 -p 0x800000 -d ./rootfs -o jffs2.img Modify u-boot env.txt env.txt is a u-boot environment variable file. u-boot can read data to RAM from Flash, boot kernel from RAM.\nThe variable bootcmd will be executed when u-boot starts and the variable bootdelay has been defined.\nThe following command will read the kernel image from Flash to RAM and boot from RAM address 7fc0.\nThe difference of command between NAND Flash and NOR Flash is NAND Flash uses nand read and the NOR Flash uses sf read.\nSf probe should have been executed first because NOR Flash should be initiated first.\nsetspi=sf probe 0 30000000\rloadkernel=sf read 7fc0 200000 600000\rbootcmd=run setspi;loadkernel;bootm 7fc0; u-boot can use MTD to partition Flash into three mtdblocks and create JFFS2 format root filesystem on mtdblock2.\nThe Flash address and size listed below can be changed to anywhere you want.\nmtdblock0 stores u-boot image and its Flash offset is from 0x0 to 0x200000. mtdblock1 stores kernel image and its Flash offset is from 0x200000 to 0x800000. mtdblock2 stores root filesystem image and its Flash offset is from 0x800000 to the end. The whole env.txt content is shown below:\nbaudrate=115200\rbootdelay=1\rstderr=serial\rstdin=serial\rstdout=serial\rsetspi=sf probe 0 30000000;\rloadkernel=sf read 7fc0 200000 600000\rbootcmd=run setspi;run loadkernel;bootm 7fc0;\rbootargs=noinitrd root=/dev/mtdblock2 rw rootfstype=jffs2 console=ttyS0 rdinit=/sbin/init mem=32M\rmtdparts=m25p80:0x200000@0x0(u-boot),0x600000@0x200000(kernel),-(user) ignore_loglevel Program Image to Evaluation Board Program the following Image files to the target board. Each image has particular address and these addresses depend on\nenv.txt.\nImage Name Image Type Address u-boot.bin Loarder 0xe00000 env.txt Env 0x80000 uImage Data 0x200000 jffs2.img Data 0x800000 Check Root Filesystem Type the following command on device terminal to check if the root filesystem has been mounted on or not.\nCompare the MTD partition you defined in env.txt with the message after you type the command below.\n/ # cat /proc/mtd\rdev: size erasesize name\rmtd0: 00200000 00010000 \u0026#34;u-boot\u0026#34;\rmtd1: 00600000 00010000 \u0026#34;kernel\u0026#34;\rmtd2: 01800000 00010000 \u0026#34;user\u0026#34; ","permalink":"https://weizongchen.github.io/blog/n9h30_quickstart/","tags":["N9H30"],"title":"N9H30 Buildroot Quick Start"},{"categories":["說明文件"],"contents":"在Buildroot中啟用SSH功能需要進行以下步驟： 1. 進入Buildroot目錄，啟動menuconfig配置工具： sudo make menuconfig\rTarget packages -\u0026gt; Networking applications -\u0026gt; [*]openssh\r[*]ethtool [*] enable pretty printing [*]dhcpcd #順便看要不要\rmake -j16 後重燒 SD 2. root 密碼 在Buildroot生成的Linux系統中，默認情況下，root用戶是沒有設置密碼的，這意味著您無法使用空密碼進行登錄。當您嘗試使用root用戶登錄時，系統會要求您輸入密碼，但實際上該密碼是不存在的。\n為了解決這個問題，您有幾個選項：\n為root用戶設置密碼：您可以登錄到Buildroot生成的Linux系統，並為root用戶設置一個密碼。在命令行中執行以下命令：\npasswd root 然後按照提示設置root用戶的密碼。設置了密碼後，您就可以使用root用戶進行遠程登錄，並輸入密碼進行身份驗證。\n3. SSH配置 檢查SSH服務器的配置文件，通常是/etc/ssh/sshd_config。確保以下設置正確：\n# vi /etc/ssh/sshd_config 直接加這兩個在最後一行就好了\nPermitRootLogin yes\rPasswordAuthentication yes 密碼權限問題：檢查root用戶的密碼文件權限是否正確。使用以下命令修復密碼文件權限：\n反正就打這個，一般我記得都是一樣的\rchmod 600 /etc/shadow 重啟SSH服務：在對SSH配置文件進行更改後，您可能需要重啟SSH服務，以使更改生效。\nreboot 最後就直接網路控制拉 ","permalink":"https://weizongchen.github.io/blog/ma35d1_openssh/","tags":["Ma35d1"],"title":"MA35D1 Buildroot 打開 openssh"},{"categories":["說明文件"],"contents":"控制LED燈 亮滅 直接控制以下節點就可以\n# ls\r# cat /sys/class/leds/LED\rLED0/ LED2/\r# cat /sys/class/leds/LED0/brightness\r0\r# cat /sys/class/leds/LED2/brightness\r0 # echo 1 \u0026gt; /sys/class/leds/LED0/brightness\r# cat /sys/class/leds/LED0/brightness\r1\r# echo 1 \u0026gt; /sys/class/leds/LED2/brightness\r# cat /sys/class/leds/LED0/brightness 控制 BTN 要控制 BTN 前，可以先確認板子上的button 是不是 work的情況 可以使用跟上面LED一樣，去cat看看button\n# cat /dev/input/event1 這個時候你去按板子上3個button，可以看到terminal會有亂碼跑出來，分別按三個都會各自跑出亂碼，如下圖所示:\n分別按三個都會各自跑出亂碼，(你會發現跑的亂碼沒有規律，以為案同一個鍵會跑出一樣的pattern。 並不會，這是正常的)\n# cat /dev/input/event1 #這個是button的\r# cat /dev/input/event0 #這個是pannel的 evtest SW Tool Buildroot 通用的Tool，evtest這個software Tool，可以用來區分你按下去的button 要測試按鈕（button）的狀態，你需要查看類似於LED的設備文件（Device File）或者介面（Interface）來讀取按鈕的狀態。這些文件通常位於 /sys 目錄下的特定位置。首先，你需要找到你的按鈕對應的設備文件位置，然後讀取它的值來確定按鈕的狀態。\n在 Linux 系統中，可以使用 evtest 工具來觀察和解讀輸入事件。\nBuildroot 選取 evtest 工具，進入 Buildroot 設定界面： make menuconfig\rTarget packages ---\u0026gt;\rHardware handling ---\u0026gt; 這邊有個註記，我在以上動作都build 完後，燒入SD卡，發現會無法進入系統，不確定什麼原因，但是我clean後就可以正常。\rmake clean make -j16 直接執行evtest就可以去測button 可以看到下圖，code 去分開3個不同的button，value 1代表被按下，value0 代表沒有按，value2 代表按住不放 注意 : touch pannel 也可以用這個evtest去測試，如下圖:\n","permalink":"https://weizongchen.github.io/blog/ma35d1_led_button/","tags":["Ma35d1"],"title":"MA35D1 LED Button Control"},{"categories":["安裝步驟文件"],"contents":"要找MA35D1的兩根pin腳給PWM 新唐定義 PG1 PG2 的地方 設定 device tree Kernel configuration settin\n/* 1. Add node in device tree root\u0026#39;s configuration */\r/ {\rmodel = \u0026#34;Nuvoton MA35D1-SOM\u0026#34;;\r………\rgpio_pwm {\rcompatible = \u0026#34;gpio-pwm\u0026#34;;\rstatus = \u0026#34;okay\u0026#34;;\rpinctrl-names = \u0026#34;default\u0026#34;;\rpinctrl-0 = \u0026lt;\u0026amp;pinctrl_gpio_pwm\u0026gt;;\rgpios = \u0026lt;\u0026amp;gpiog 1 GPIO_ACTIVE_LOW\u0026gt;,\r\u0026lt;\u0026amp;gpiog 2 GPIO_ACTIVE_LOW\u0026gt;; };\r………\r};\r/* 2. Add module pin configuration to device tree\u0026#39;s pinctl as below */\r\u0026amp;pinctrl {\r………\rgpio_pwm {\rpinctrl_gpio_pwm: gpio_pwmgrp{\rnuvoton,pins =\r\u0026lt;SYS_GPG_MFPL_PG1MFP_GPIO \u0026amp;pcfg_default\u0026gt;,\r\u0026lt;SYS_GPG_MFPL_PG2MFP_GPIO \u0026amp;pcfg_default\u0026gt;;\r};\t};\r……… gpio-pwm 的Driver gpio-pwm.c #include \u0026lt;linux/module.h\u0026gt;\r#include \u0026lt;linux/kernel.h\u0026gt;\r#include \u0026lt;linux/init.h\u0026gt;\r#include \u0026lt;linux/slab.h\u0026gt;\r#include \u0026lt;linux/timer.h\u0026gt;\r#include \u0026lt;linux/sched.h\u0026gt;\r#include \u0026lt;linux/reboot.h\u0026gt;\r#include \u0026lt;linux/pwm.h\u0026gt;\r#include \u0026lt;linux/gpio.h\u0026gt;\r#include \u0026lt;linux/hrtimer.h\u0026gt;\r#include \u0026lt;linux/platform_device.h\u0026gt;\r#include \u0026lt;linux/of.h\u0026gt;\r#include \u0026lt;linux/of_platform.h\u0026gt;\r#include \u0026lt;linux/of_gpio.h\u0026gt;\r#include \u0026#34;gpio_pwm.h\u0026#34;\r#define GPIO_STATE_DEFAULT 0\rstruct gpio_pwm_driver_data {\runsigned int gpio;\rbool gpio_state;\rstruct pwm_device *pwm_dev;\rbool pwm_enable;\rbool pwm_requset; struct hrtimer timer;\rstruct mutex lock;\r};\rstruct gpio_pwm_chip {\rstruct pwm_chip chip;\rint gpio_nums;\rstruct gpio_pwm_driver_data gpio_pwm_drv_data[];\r};\rstatic enum hrtimer_restart gpio_pwm_timer_fun(struct hrtimer *data)\r{\rint gpio_pwm_hi_time = 0;\rint gpio_pwm_lo_time = 0;\rint gpio_keep_time = 0;\rstruct gpio_pwm_driver_data *gpio_pwm_drv = container_of(data, struct gpio_pwm_driver_data, timer);\rstruct pwm_device *pwm_dev = gpio_pwm_drv-\u0026gt;pwm_dev;\rgpio_pwm_hi_time = pwm_dev-\u0026gt;state.duty_cycle;\rgpio_pwm_lo_time = pwm_dev-\u0026gt;state.period - pwm_dev-\u0026gt;state.duty_cycle;\rif(gpio_pwm_drv-\u0026gt;gpio_state == 0) {\rgpio_keep_time = gpio_pwm_hi_time;\r} else {\rgpio_keep_time = gpio_pwm_lo_time;\r}\rgpio_pwm_drv-\u0026gt;gpio_state ^= 0x01;\rgpio_set_value(gpio_pwm_drv-\u0026gt;gpio, gpio_pwm_drv-\u0026gt;gpio_state);\rhrtimer_forward_now(\u0026amp;gpio_pwm_drv-\u0026gt;timer, ns_to_ktime(gpio_keep_time));\rreturn HRTIMER_RESTART;\r}\rstatic int gpio_pwm_request(struct pwm_chip *chip, struct pwm_device *pwm)\r{\rstruct gpio_pwm_chip *pwm_chip_ptr = container_of(chip, struct gpio_pwm_chip, chip);\rstruct gpio_pwm_driver_data *gpio_pwm_drv = \u0026amp;(pwm_chip_ptr-\u0026gt;gpio_pwm_drv_data[pwm-\u0026gt;hwpwm]);\rint ret = 0;\rret = gpio_request_one(gpio_pwm_drv-\u0026gt;gpio, GPIOF_DIR_OUT, pwm-\u0026gt;label);\rif (ret == 0) {\rgpio_pwm_drv-\u0026gt;gpio_state = GPIO_STATE_DEFAULT;\rgpio_set_value(gpio_pwm_drv-\u0026gt;gpio, gpio_pwm_drv-\u0026gt;gpio_state);\rgpio_pwm_drv-\u0026gt;pwm_requset = 1;\r}\rreturn ret;\r}\rstatic void gpio_pwm_free(struct pwm_chip *chip, struct pwm_device *pwm)\r{\rstruct gpio_pwm_chip *pwm_chip_ptr = container_of(chip, struct gpio_pwm_chip, chip);\rstruct gpio_pwm_driver_data *gpio_pwm_drv = \u0026amp;(pwm_chip_ptr-\u0026gt;gpio_pwm_drv_data[pwm-\u0026gt;hwpwm]);\rint i;\rmutex_lock(\u0026amp;gpio_pwm_drv-\u0026gt;lock);\rif(gpio_pwm_drv-\u0026gt;pwm_enable) {\rhrtimer_cancel(\u0026amp;gpio_pwm_drv-\u0026gt;timer);\rgpio_pwm_drv-\u0026gt;pwm_enable = false;\r}\rmutex_unlock(\u0026amp;gpio_pwm_drv-\u0026gt;lock);\rfor(i=0; i \u0026lt; pwm_chip_ptr-\u0026gt;gpio_nums; i++) {\rif (gpio_pwm_drv-\u0026gt;pwm_requset == 1) { gpio_free(gpio_pwm_drv-\u0026gt;gpio);\r}\r}\r}\rstatic int gpio_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm)\r{\rstruct gpio_pwm_chip *pwm_chip_ptr = container_of(chip, struct gpio_pwm_chip, chip);\rstruct gpio_pwm_driver_data *gpio_pwm_drv = \u0026amp;(pwm_chip_ptr-\u0026gt;gpio_pwm_drv_data[pwm-\u0026gt;hwpwm]);\rmutex_lock(\u0026amp;gpio_pwm_drv-\u0026gt;lock);\rif(!gpio_pwm_drv-\u0026gt;pwm_enable) {\rhrtimer_init(\u0026amp;gpio_pwm_drv-\u0026gt;timer, CLOCK_REALTIME, HRTIMER_MODE_ABS);\rgpio_pwm_drv-\u0026gt;timer.function = gpio_pwm_timer_fun;\rgpio_pwm_drv-\u0026gt;pwm_enable = true;\r}\rmutex_unlock(\u0026amp;gpio_pwm_drv-\u0026gt;lock);\rhrtimer_start(\u0026amp;gpio_pwm_drv-\u0026gt;timer, ktime_add_ns(ktime_get(), pwm-\u0026gt;state.duty_cycle), HRTIMER_MODE_ABS);\rreturn 0;\r}\rstatic int gpio_pwm_config(struct pwm_chip *chip, struct pwm_device *pwm, int duty_ns, int period_ns)\r{\rpwm-\u0026gt;state.period = period_ns;\rpwm-\u0026gt;state.duty_cycle = duty_ns;\rreturn 0;\r}\rstatic void gpio_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm)\r{\rstruct gpio_pwm_chip *pwm_chip_ptr = container_of(chip, struct gpio_pwm_chip, chip);\rstruct gpio_pwm_driver_data * gpio_pwm_drv = \u0026amp;(pwm_chip_ptr-\u0026gt;gpio_pwm_drv_data[pwm-\u0026gt;hwpwm]);\rmutex_lock(\u0026amp;gpio_pwm_drv-\u0026gt;lock);\rif(gpio_pwm_drv-\u0026gt;pwm_enable) {\rhrtimer_cancel(\u0026amp;gpio_pwm_drv-\u0026gt;timer);\rgpio_pwm_drv-\u0026gt;pwm_enable = false;\r}\rmutex_unlock(\u0026amp;gpio_pwm_drv-\u0026gt;lock);\r}\rstatic struct pwm_ops gpio_pwm_ops = {\r.request = gpio_pwm_request,\r.free = gpio_pwm_free,\r.enable = gpio_pwm_enable,\r.disable = gpio_pwm_disable,\r.config = gpio_pwm_config,\r.owner = THIS_MODULE,\r};\r#ifdef CONFIG_OF\rstatic const struct of_device_id of_gpio_pwm_match[] = {\r{ .compatible = \u0026#34;gpio-pwm\u0026#34;, },\r{},\r};\r#endif\rstatic struct gpio_pwm_chip *gpio_pwmparse_dt(struct device *dev)\r{\rconst struct of_device_id *of_id = of_match_device(of_gpio_pwm_match, dev);\rstruct device_node *np = dev-\u0026gt;of_node;\renum of_gpio_flags flags;\rstruct gpio_pwm_chip *pwm_chip_ptr;\rint gpio_nums;\rint i;\rint err;\rif (!of_id || !np)\rreturn NULL;\rgpio_nums = of_gpio_count(np);\rif (!gpio_nums) return ERR_PTR(-ENODEV); printk(\u0026#34;gpio_nums = %d\\n\u0026#34;, gpio_nums);\rpwm_chip_ptr = devm_kzalloc(dev, sizeof(struct gpio_pwm_chip) + (gpio_nums * sizeof(struct gpio_pwm_driver_data)), GFP_KERNEL);\rif (!pwm_chip_ptr)\rreturn ERR_PTR(-ENOMEM);\rpwm_chip_ptr-\u0026gt;gpio_nums = gpio_nums;\rfor(i = 0; i \u0026lt; gpio_nums; i++) {\rpwm_chip_ptr-\u0026gt;gpio_pwm_drv_data[i].gpio = of_get_gpio_flags(np, i, \u0026amp;flags);\rmutex_init(\u0026amp;(pwm_chip_ptr-\u0026gt;gpio_pwm_drv_data[i].lock));\rpwm_chip_ptr-\u0026gt;gpio_pwm_drv_data[i].pwm_enable = false;\rprintk(\u0026#34;gpio=%d\\n\u0026#34;, pwm_chip_ptr-\u0026gt;gpio_pwm_drv_data[i].gpio);\r}\rerr = of_property_read_u32(np, \u0026#34;base\u0026#34;, \u0026amp;pwm_chip_ptr-\u0026gt;chip.base);\rif (err)\rpwm_chip_ptr-\u0026gt;chip.base = 0x20;\rreturn pwm_chip_ptr;\r}\rstatic int gpio_pwm_probe(struct platform_device *pdev)\r{\rstruct device *dev = \u0026amp;pdev-\u0026gt;dev;\rstruct gpio_pwm_platform_data *pdata = (struct gpio_pwm_platform_data *)dev_get_platdata(dev);\rstruct gpio_pwm_chip *pwm_chip_ptr = NULL;\rint i = 0;\rint ret = 0;\rif (!pdata) {\rprintk(\u0026#34;probe dt\\n\u0026#34;);\rpwm_chip_ptr = gpio_pwmparse_dt(dev);\rif (IS_ERR(pwm_chip_ptr))\rreturn PTR_ERR(pwm_chip_ptr);\rif (!pwm_chip_ptr) {\rdev_err(dev, \u0026#34;pwm gpio missing platform data\\n\u0026#34;);\rreturn -EINVAL;\r}\r} else {\rpwm_chip_ptr = devm_kzalloc(\u0026amp;pdev-\u0026gt;dev, sizeof(struct gpio_pwm_chip) + (pdata-\u0026gt;gpio_nums * sizeof(struct gpio_pwm_driver_data)), GFP_KERNEL);\rif(pwm_chip_ptr == NULL)\rreturn -ENOMEM;\rpwm_chip_ptr-\u0026gt;gpio_nums = pdata-\u0026gt;gpio_nums;\rfor(i=0; i \u0026lt; pdata-\u0026gt;gpio_nums; i++) {\rpwm_chip_ptr-\u0026gt;gpio_pwm_drv_data[i].gpio = pdata-\u0026gt;gpios[i];\rmutex_init(\u0026amp;(pwm_chip_ptr-\u0026gt;gpio_pwm_drv_data[i].lock));\rpwm_chip_ptr-\u0026gt;gpio_pwm_drv_data[i].pwm_enable = false;\rprintk(\u0026#34;gpio-%d\\n\u0026#34;,pwm_chip_ptr-\u0026gt;gpio_pwm_drv_data[i].gpio);\r}\rpwm_chip_ptr-\u0026gt;chip.base = pdata-\u0026gt;pwm_chip_idx;\rprintk(\u0026#34;pwm_chip_idx=%d\\n\u0026#34;, pdata-\u0026gt;pwm_chip_idx);\r}\rpwm_chip_ptr-\u0026gt;chip.npwm = pwm_chip_ptr-\u0026gt;gpio_nums;\rpwm_chip_ptr-\u0026gt;chip.ops = \u0026amp;gpio_pwm_ops;\rpwm_chip_ptr-\u0026gt;chip.dev = \u0026amp;pdev-\u0026gt;dev;\r#ifdef CONFIG_OF pwm_chip_ptr-\u0026gt;chip.dev-\u0026gt;of_node = pdev-\u0026gt;dev.of_node;\r#endif\rret = pwmchip_add(\u0026amp;pwm_chip_ptr-\u0026gt;chip);\rif(ret) {\rreturn ret;\r}\rfor(i = 0; i \u0026lt; pwm_chip_ptr-\u0026gt;gpio_nums; i++) {\rpwm_chip_ptr-\u0026gt;gpio_pwm_drv_data[i].pwm_dev = \u0026amp;pwm_chip_ptr-\u0026gt;chip.pwms[i];\r}\rplatform_set_drvdata(pdev, pwm_chip_ptr);\rreturn 0;\r}\rstatic int gpio_pwm_remove(struct platform_device *pdev)\r{\rstruct gpio_pwm_chip *pwm_chip_ptr = platform_get_drvdata(pdev);\rpwmchip_remove(\u0026amp;pwm_chip_ptr-\u0026gt;chip);\rplatform_set_drvdata(pdev, NULL);\rreturn 0;\r}\rstatic struct platform_driver gpio_pwm_driver = {\r.probe\t= gpio_pwm_probe,\r.remove\t= gpio_pwm_remove,\r.driver\t= {\r.name\t= \u0026#34;gpio-pwm\u0026#34;,\r.owner\t= THIS_MODULE,\r.of_match_table = of_match_ptr(of_gpio_pwm_match),\r},\r};\rmodule_platform_driver(gpio_pwm_driver);\rMODULE_AUTHOR(\u0026#34;nuvoton porting\u0026#34;);\rMODULE_DESCRIPTION(\u0026#34;gpio pwm chip driver\u0026#34;);\rMODULE_LICENSE(\u0026#34;GPL\u0026#34;); gpio-pwm.h #ifndef __GPIO_PWM_H\r#define __GPIO_PWM_H\r#include \u0026lt;linux/kernel.h\u0026gt;\r#include \u0026lt;linux/init.h\u0026gt;\r#include \u0026lt;linux/slab.h\u0026gt;\rstruct gpio_pwm_platform_data {\rint pwm_chip_idx;\rint gpio_nums;\runsigned int *gpios;\r};\r#endif MakeFile to Build gpio-pwm.ko 下面要注意 :\n在docker裡面 make LINUX_DIR 要擺已經Build過的 kernel 位置 aarch64 tool chain 要有 : source /usr/local/oecore-x86_64/environment-setup-aarch64-poky-linux PWD := $(shell pwd)\robj-m += gpio-pwm.o\r.PHONY: all clean\rCOMPILE=aarch64-poky-linux-\rLINUX_DIR=../tmp-glibc/work/numaker_som_ma35d16a81-poky-linux/linux-ma35d1/5.10.140-r0/build\rall:\rmake ARCH=arm64 CROSS_COMPILE=$(COMPILE) -C $(LINUX_DIR) M=$(PWD) modules\r結構應該長得像下面的資料夾 實體接線 AP 層控制 GPIO PWM執行輸出與佔空比設定\nExport PWM\necho 0 \u0026gt; /sys/class/pwm/pwmchip32/export PWM 週期設定,單位為ns, gpioi12 輸出頻率為 100 HZ\necho 10000000 \u0026gt; /sys/class/pwm/pwmchip32/pwm0/period PWM 佔空比設定, 以下設定佔空比為 0.5\necho 5000000 \u0026gt; /sys/class/pwm/pwmchip32/pwm0/duty_cycle PWM 使能輸出\necho 1 \u0026gt;/sys/class/pwm/pwmchip32/pwm0/enable echo 0 會 export ，這個時候，會出現pwm0的節點 echo 0 \u0026gt; /sys/class/pwm/pwmchip32/export\recho 20000000 \u0026gt; /sys/class/pwm/pwmchip32/pwm0/period\recho 1000000 \u0026gt; /sys/class/pwm/pwmchip32/pwm0/duty_cycle\recho 2000000 \u0026gt; /sys/class/pwm/pwmchip32/pwm0/duty_cycle\recho 1 \u0026gt;/sys/class/pwm/pwmchip32/pwm0/enable PWM1 也是差不多的方式 echo 1 export ，這個時候會出現pwm1的節點\necho 1 \u0026gt; /sys/class/pwm/pwmchip32/export\recho 20000000 \u0026gt; /sys/class/pwm/pwmchip32/pwm1/period\recho 1000000 \u0026gt; /sys/class/pwm/pwmchip32/pwm1/duty_cycle\recho 2000000 \u0026gt; /sys/class/pwm/pwmchip32/pwm1/duty_cycle\recho 1 \u0026gt;/sys/class/pwm/pwmchip32/pwm1/enable SG90 伺服馬達說明 小巧輕便且輸出功率高。伺服馬達可以大約旋轉180度（每個方向90度），並且與標準的伺服馬達一樣工作，只是體積更小。\n您可以使用任何伺服馬達的程式碼、硬體或庫來控制這些伺服馬達。\n對於初學者來說非常適合，他們想要讓東西移動，而不需要建立帶有反饋和齒輪箱的馬達控制器，尤其是因為它可以放在狹小的空間中。\n位置 \u0026ldquo;0\u0026rdquo;（1.5 毫秒脈衝）代表中間位置。\n位置 \u0026ldquo;90\u0026rdquo;（約 2 毫秒脈衝）代表向右極限。\n位置 \u0026ldquo;-90\u0026rdquo;（約 1 毫秒脈衝）代表向左極限。\n簡單來說，這段描述了 PWM 信號的位置與對應的角度之間的關係。位置 \u0026ldquo;0\u0026rdquo; 代表中間位置，位置 \u0026ldquo;90\u0026rdquo; 代表完全向右轉的極限，而位置 \u0026ldquo;-90\u0026rdquo; 則代表完全向左轉的極限。這些位置對應於 PWM 脈衝的持續時間，可以控制舵機或其他類似裝置的運動位置。\n注意 100 Hz 是 :\necho 10000000 \u0026gt; /sys/class/pwm/pwmchip32/pwm0/period\nDatashet 要 50 Hz\n要寫成以下才會是50 Hz:\necho 20000000 \u0026gt; /sys/class/pwm/pwmchip32/pwm0/period 1 ms 的duty 我要給以下:\necho 1000000 \u0026gt; /sys/class/pwm/pwmchip32/pwm0/duty_cycle\n1.5 ms 的duty 我要給以下:\necho 1500000 \u0026gt; /sys/class/pwm/pwmchip32/pwm0/duty_cycle\n2 ms 的duty 我要給以下:\necho 2000000 \u0026gt; /sys/class/pwm/pwmchip32/pwm0/duty_cycle\n","permalink":"https://weizongchen.github.io/blog/ma35d1_pwm_control/","tags":["MA35D1"],"title":"MA35D1 Control "},{"categories":["心得"],"contents":" 控制 LED 0x4000_4000 是一個32位元的記憶體位址，所以我需要一個 uint32_t* 去接他\nuint32_t* ptr_mode;\rptr_mode = (uint32_t*)(0x40004000 + 0x1c0);\r*ptr_mode = 0x00000100;\ruint32_t* ptr_value;\rptr_value = (uint32_t*)(0x40004000 + 0x1c8);\r*ptr_value = 0xFFFFFFEF; 負源觸發\r補充說明 : 也可以使用 Keil 的 tool 看，如下圖所示:\n所以新唐寫法 uint32_t* ptr_mode;\rptr_mode = (uint32_t*)(0x40004000 + 0x1c0);\r*ptr_mode = 0x00000100;\ruint32_t* ptr_value;\rptr_value = (uint32_t*)(0x40004000 + 0x1c8);\r*ptr_value = 0xFFFFFFEF;\r//----------------和下面寫法一樣-----------------------------------\rGPIO_SetMode(PH, BIT4, GPIO_MODE_OUTPUT);\rGPIO_SetMode(PH, BIT5, GPIO_MODE_OUTPUT);\rGPIO_SetMode(PH, BIT6, GPIO_MODE_OUTPUT);\rLED_YELLOW = 0;//PH5\rLED_RED = 1; //PH4\rLED_GREEN = 0; //PH6\r控制 BTN 先用 Keil 的Tool 看一下 按下Button 的狀態\nGPIO_SetMode(PH, BIT4, GPIO_MODE_OUTPUT);\rGPIO_SetMode(PH, BIT5, GPIO_MODE_OUTPUT);\rGPIO_SetMode(PH, BIT6, GPIO_MODE_OUTPUT);\rLED_YELLOW = 1;//PH5\rLED_RED = 1; //PH4\rLED_GREEN = 1; //PH6\rGPIO_SetMode(PH, BIT0, GPIO_MODE_INPUT);\r/* Got no where to go, just loop forever */\rwhile(1) {\rif(PH0 == 0){\rLED_RED = 0; //PH4\r}\rif(PH0 == 1){\rLED_RED = 1; //PH4\r}\r}\r","permalink":"https://weizongchen.github.io/blog/m460_level0/","tags":["Cortex M4"],"title":" M460 Level0 說明"},{"categories":["安裝步驟文件"],"contents":"yocto添加網路上現有的meta layer 查找菜譜 可以點下面連結去首頁\nOpenEmbedded Layer Index\n也可以直接點下面是 Tensorflow Lite 的資源\nmeta-neural-network\n如下圖，目前是tensorflow2.6.0版本( dunfell )\n找到Source Code 如下圖，點擊 web repo 會到Github的頁面\n目前是dunfell ，要改成dunfell的source Download Source Code 在 bitbake 裡面下以下指令去Download Code git clone -b dunfell https://github.com/nnstreamer/meta-neural-network.git 下載成功的畫面 裡面內容大概長成下面:\n在 bblayers.conf 加入 meta-neural-network 在 local.conf 加入 tensorflow-lite 編譯一次Image 編譯一次nvt-image-qt5的Image ， bitbake -s | grep tensorflow-lite 就應該可以看到tensorflow lite 的 library 被加到Image 裡面。\n過程當中，Tensorflow lite 的資源裡面，會發現 XNNPACK 相關的 error 一直跑出來 Debug 後 ， 發現要 -DTFLITE_ENABLE_XNNPACK=off ， 把XNNPACK給off掉，如下圖所示\n直接找到他把它關掉 EXTRA_OECMAKE = \u0026#34;\\\r-DTFLITE_ENABLE_XNNPACK=off \\\r-DTFLITE_ENABLE_RUY=on \\\r-DTFLITE_ENABLE_GPU=off \\\r${S}/tensorflow/lite/ \\ Tensorflow-Lite 加入成功 加入 VNC 相關的 Library 下面這幾個library 是跟tigervnc相關:\ngtk+3 、 tigervnc 、 xauth 、 xkbcomp 、 xsetroot 、 xterm 、 twm\nMACHINE ??= \u0026#39;numaker-som-ma35d16a81\u0026#39;\rDISTRO ?= \u0026#39;nvt-ma35d1-directfb\u0026#39;\rPACKAGE_CLASSES ?= \u0026#34;package_rpm\u0026#34;\rEXTRA_IMAGE_FEATURES ?= \u0026#34;debug-tweaks\u0026#34;\rUSER_CLASSES ?= \u0026#34;buildstats image-mklibs image-prelink\u0026#34;\rPATCHRESOLVE = \u0026#34;noop\u0026#34;\rBB_DISKMON_DIRS ??= \u0026#34;\\\rSTOPTASKS,${TMPDIR},1G,100K \\\rSTOPTASKS,${DL_DIR},1G,100K \\\rSTOPTASKS,${SSTATE_DIR},1G,100K \\\rSTOPTASKS,/tmp,100M,100K \\\rABORT,${TMPDIR},100M,1K \\\rABORT,${DL_DIR},100M,1K \\\rABORT,${SSTATE_DIR},100M,1K \\\rABORT,/tmp,10M,1K\u0026#34;\rPACKAGECONFIG_append_pn-qemu-system-native = \u0026#34; sdl\u0026#34;\rCONF_VERSION = \u0026#34;1\u0026#34;\rMACHINE_FEATURES_append = \u0026#34; optee \u0026#34;\rIMAGE_INSTALL_append += \u0026#34; opencv\u0026#34;\rIMAGE_INSTALL_append += \u0026#34; tensorflow-lite\u0026#34;\rIMAGE_INSTALL_append += \u0026#34; gtk+3\u0026#34;\rIMAGE_INSTALL_append += \u0026#34; tigervnc\u0026#34;\rIMAGE_INSTALL_append += \u0026#34; xauth\u0026#34;\rIMAGE_INSTALL_append += \u0026#34; xkbcomp\u0026#34;\rIMAGE_INSTALL_append += \u0026#34; xsetroot\u0026#34;\rIMAGE_INSTALL_append += \u0026#34; xterm\u0026#34;\rIMAGE_INSTALL_append += \u0026#34; twm\u0026#34;\rIMAGE_INSTALL_append += \u0026#34; cmake\u0026#34;\rDL_DIR ?= \u0026#34;${BSPDIR}/downloads/\u0026#34; 編譯 nvt-image-qt5 的 Image 時候會看到 下面 x11 錯誤\n點開下面的 nvt-ma35d1-directfb.conf 檔案，加入x11 的內容就可以了\n路徑:\r/home/nuvoton/yocto/sources/meta-ma35d1/conf/distro\r# Nuvoton DISTRO for the FrameBuffer graphical backend.\rinclude conf/distro/include/nvt-base.inc\rDISTRO = \u0026#34;nvt-ma35d1-directfb\u0026#34;\r# Remove conflicting backends.\rDISTRO_FEATURES_append += \u0026#34; \u0026#34;\rDISTRO_FEATURES_append += \u0026#34; x11 \u0026#34; 再 bitbake nvt-image-qt5 一次，就可以全部都加進去\n","permalink":"https://weizongchen.github.io/blog/add_tensorflow_lite_to_ma35d1_yocto/","tags":["Ma35d1"],"title":" 將Tensorflow Lite Library加到MA35D1的Yocto中 "},{"categories":["說明文件"],"contents":"Open local.conf nuvoton@84d536ecc45d:~/shared/yocto/build$ vim conf/local.conf For example : add pip3 and devmem2 CORE_IMAGE_EXTRA_INSTALL += \u0026ldquo;devmem2\u0026rdquo;\nIMAGE_INSTALL_append += \u0026quot; python3-pip\u0026quot;\nMACHINE ??= \u0026#39;numaker-iot-ma35d16f90\u0026#39;\rDISTRO ?= \u0026#39;nvt-ma35d1-directfb\u0026#39;\rPACKAGE_CLASSES ?= \u0026#34;package_rpm\u0026#34;\rEXTRA_IMAGE_FEATURES ?= \u0026#34;debug-tweaks\u0026#34;\rUSER_CLASSES ?= \u0026#34;buildstats image-mklibs image-prelink\u0026#34;\rPATCHRESOLVE = \u0026#34;noop\u0026#34;\rBB_DISKMON_DIRS ??= \u0026#34;\\\rSTOPTASKS,${TMPDIR},1G,100K \\\rSTOPTASKS,${DL_DIR},1G,100K \\\rSTOPTASKS,${SSTATE_DIR},1G,100K \\\rSTOPTASKS,/tmp,100M,100K \\\rABORT,${TMPDIR},100M,1K \\\rABORT,${DL_DIR},100M,1K \\\rABORT,${SSTATE_DIR},100M,1K \\\rABORT,/tmp,10M,1K\u0026#34;\rPACKAGECONFIG_append_pn-qemu-system-native = \u0026#34; sdl\u0026#34;\rCONF_VERSION = \u0026#34;1\u0026#34;\rMACHINE_FEATURES_append = \u0026#34; optee\u0026#34;\rCORE_IMAGE_EXTRA_INSTALL += \u0026#34;devmem2\u0026#34;\rIMAGE_INSTALL_append += \u0026#34; python3-pip\u0026#34;\rDL_DIR ?= \u0026#34;${BSPDIR}/downloads/\u0026#34; Search package nuvoton@84d536ecc45d:~/shared/yocto/build$ bitbake -s | grep pip\nlibpipeline :1.5.2-r0 nativesdk-python3-pip :20.0.2-r0 pipewire :0.3.1-r0 pipewire-0.2 :0.2.7-r0 python3-pip :20.0.2-r0 python3-pip-native :20.0.2-r0 ","permalink":"https://weizongchen.github.io/blog/ma35d1_extra_package_yocto/","tags":["MA35D1"],"title":"MA35D1 extra package in Yocto project after the image is built"},{"categories":["說明文件"],"contents":"devmem2 Tool read register devmem2 0x40600014 TRM SPI Status Register (SPIx_STATUS) write 32bit to register devmem2 0x40600014 w 0x0058112 ","permalink":"https://weizongchen.github.io/blog/ma35d1_devmem2/","tags":["MA35D1"],"title":"MA35D1 devmem2 Read / Write memory address"},{"categories":["說明文件"],"contents":"MA35D1 QT startup path vi /etc/profile.d/qt5-env.sh You can write that you want to auto execute command or script here. Here, I setup a IP and a gpio driver when startup the A35. #define a new path for the font in qt5\rexport QT_QPA_FONTDIR=/usr/share/fonts/truetype\rexport XDG_RUNTIME_DIR=\u0026#34;/tmp/runtime-root\u0026#34;\rexport QT_QPA_PLATFORM=\u0026#34;linuxfb\u0026#34;\rexport QT_QPA_FB_TSLIB=1\rexport TSLIB_CONSOLEDEVICE=none\rifconfig eth1 192.168.11.6 netmask 255.255.255.0\rinsmod ~/gpio-capture.ko SCP a file test sudo scp spidev_test3 root@192.168.11.6:/home/root/\n","permalink":"https://weizongchen.github.io/blog/ma35d1_startup_execute/","tags":["MA35D1"],"title":"MA35D1 開機啟動位置"},{"categories":["說明文件"],"contents":"MA35D1 SPI Device Tree 路徑 : ~/yocto/build/tmp-glibc/work-shared/numaker-iot-ma35d16f90/kernel-source/arch/arm64/boot/dts/nuvoton/ma35d1.dtsi\nspi0: spi@40600000 {\rcompatible = \u0026#34;nuvoton,ma35d1-spi\u0026#34;;\rreg = \u0026lt;0x0 0x40600000 0x0 0x10000\u0026gt;;\rinterrupts = \u0026lt;GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH\u0026gt;;\rclocks = \u0026lt;\u0026amp;clk SPI0_GATE\u0026gt;;\rdmas = \u0026lt;\u0026amp;pdma1 4\u0026gt;,\u0026lt;\u0026amp;pdma1 5\u0026gt;;\rdma-names = \u0026#34;tx\u0026#34;,\u0026#34;rx\u0026#34;;\rpdma_reqsel_tx = \u0026lt;60\u0026gt;;\rpdma_reqsel_rx = \u0026lt;61\u0026gt;;\ruse_pdma = \u0026lt;0\u0026gt;;\rnum_cs = \u0026lt;2\u0026gt;;\rlsb = \u0026lt;0\u0026gt;;\rsleep = \u0026lt;0\u0026gt;;\rtxbitlen = \u0026lt;8\u0026gt;;\rbus_num = \u0026lt;2\u0026gt;;\rspimode = \u0026lt;0\u0026gt;;\rmrxphase = \u0026lt;0\u0026gt;;\rspi-max-frequency = \u0026lt;10000000\u0026gt;;\rstatus = \u0026#34;disabled\u0026#34;;\r}; 路徑 : ~/yocto/build/tmp-glibc/work-shared/numaker-iot-ma35d16f90/kernel-source/arch/arm64/boot/dts/nuvoton/ma35d1-iot-512m.dts\nCS = PG0\nCLK = PB9\nMOSI = PL14\nMISO =PL15\n使用PDMA 所以下面給1\n速度最高給12M (後面會蓋掉前面設定!)\n\u0026amp;spi0 {\rstatus = \u0026#34;okay\u0026#34;;\rpinctrl-names = \u0026#34;default\u0026#34;;\ruse_pdma = \u0026lt;1\u0026gt;;\rspi-max-frequency = \u0026lt;30000000\u0026gt;;\rpinctrl-0 = \u0026lt;\u0026amp;pinctrl_spi0\u0026gt;;\rspidev@0 {\rcompatible = \u0026#34;spidev\u0026#34;;\rreg = \u0026lt;0\u0026gt;;\rspi-max-frequency = \u0026lt;12000000\u0026gt;;\r};\r};\r\u0026amp;pinctrl {\rspi0 {\rpinctrl_spi0: spi0grp{\rnuvoton,pins =\r\u0026lt;SYS_GPG_MFPL_PG0MFP_SPI0_SS0 \u0026amp;pcfg_default\u0026gt;,\r\u0026lt;SYS_GPB_MFPH_PB8MFP_SPI0_SS1 \u0026amp;pcfg_default\u0026gt;,\r\u0026lt;SYS_GPB_MFPH_PB9MFP_SPI0_CLK \u0026amp;pcfg_default\u0026gt;,\r\u0026lt;SYS_GPL_MFPH_PL14MFP_SPI0_MOSI \u0026amp;pcfg_default\u0026gt;,\r\u0026lt;SYS_GPL_MFPH_PL15MFP_SPI0_MISO \u0026amp;pcfg_default\u0026gt;;\r};\r};\r}; 電路圖 Linux Driver: 路徑 : ~/yocto/build/tmp-glibc/work-shared/numaker-iot-ma35d16f90/kernel-source/drivers/spi\nstatic int nuvoton_spi_data_xfer(struct nuvoton_spi *hw, const void *txbuf,\rvoid *rxbuf, unsigned int len)\r{\r...\r} Linux Application: 環境上預設並沒有開啟spidev (decice node for user)須經由以下流程開啟: APP: 採用NUC980的 app https://github.com/OpenNuvoton/NUC980_Linux_Applications/blob/master/demos/spi/spidev_test.c\nAPP Makefile .SUFFIXES : .x .o .c .s\rSTRIP := aarch64-poky-linux-strip\r#TARGET = spidev_test\r#SRCS := spidev_test.c\rall:\r#\t$(CC) $(SRCS) -o $(TARGET) clean:\rrm -f *.o\rrm -f *.x\rrm -f *.flat\rrm -f *.map\rrm -f temp\rrm -f *.img\rrm -f $(TARGET)\rrm -f *.gdb Application 執行結果 ","permalink":"https://weizongchen.github.io/blog/ma35d1_spi/","tags":["MA35D1"],"title":"MA35D1 IoT 的 SPI 介面使用"},{"categories":["說明文件"],"contents":"跟新唐過去Cortex® M4 的 Feature 不一樣的地方 M4 speed 調升至 180 MHz 本章的重點，SRAM 有 128KB 以及 可以控制DDR 384KB Support Peripheral 1. UART、I2C、I2S、PDMA、SPI、etc… NuLink2Me Debug Wormhole Linux Setup Device Tree 查看各個 memory 設定 這裡是設定 Memory 的起始位置 8000 0000\n注意 Reserved-memory :\n在這裡，我們為不同的功能保留了三個塊。 其中一個地方是 rproc 函數，它用在 M4 DRAM 上(384KB)\n(0x60000 = 384 KB)\nDevice Tree 設定 以設定UART16 為例\n_S 就是代表指定給A35\n_SUBM 代表指定給M4\nCompile and make Image Compile the Linux kernel.\r$ bitbake linux-ma35d1 -C compile\rCompile the TF-A.\r$ bitbake tf-a-ma35d1 -C compile\rBuild-up Image.\r$ bitbake nvt-image-qt5 –c cleanall \u0026amp;\u0026amp; bitbake nvt-image-qt5\rBurn-in Image into SD card.\r$ sudo dd if=core-image-minimal-xxxxx.rootfs.sdcard of=/dev/sdbx 在 Keil IDE 設定 memory 使用空間 上圖中我們可以看到，RO data 配置位置在 0x0 ~ 0x1FFFF ，一共有128KB SRAM\nRW data 配置位置在 0x80040000 大小為0x1FFFF ，一共有128KB 的DDR\n我寫一個 c code 在 DDR memory 使用空間 在 .c 的右鍵 option ，可以指定要把這個 function 放到 DDR 去\n在 map file 中可以看到 memtest 已經在DDR 的 使用空間了\n使用 scatter file 去直接指定 哪個 上圖可以看到 紅色 是代表記憶體區間\n0x00000000 ~ 0x0001FFFF 是SRAM 的空間\n這裡的寫法可以直接打開 map file ，copy paste 一模一樣的名子就可以了，\n例如 : startup_ma35d1_rtp.o(STACK, HEAP) 這個我放到SRAM\npdm_converter.o(.bss) 我放到DRAM\n以此類推\n所以上圖可以知道，我把需要比較快速算完的data 放到SRAM\n比較不需要速度的資料我放到 DRAM\n","permalink":"https://weizongchen.github.io/blog/ma35d1_rtp_memory/","tags":["Cortex M4","MA35D1"],"title":"解決 MA35D1 M4 SRAM 128KB 不夠，調用A35 DDR space 384KB 的方法"},{"categories":["說明文件"],"contents":"PC 接好onboard的 nulink2 然後設定 Keil 的 option 這邊可以看到上圖我們開啟了412KB 的 flash 要使用\n在程式的部分，我open 一個 fmc\n寫一個pattern : 0x5A5A5A5A\n然後下面有兩個API可以參考(FMC_Write 、 FMC_Read)，其他可以去看新唐的fmc.c 參考。\n可以看到，我們用ICP查詢片上的flash 有0x5A5A5A5A 的資料被寫入\nFMC_Erase(u32Addr) 一次會Erase 4096 個 byte uTemp 一次要寫入 4 byte 的資料\nelse if( (i*4) == 4096)\n因為一次會寫入4 byte，所以當i=1024時，寫買了需要Erase新的4096 byte 空間\n","permalink":"https://weizongchen.github.io/blog/m4_fmc/","tags":["Cortex M4"],"title":"M4 把資料寫進 FMC的方法"},{"categories":["說明文件"],"contents":"Raspberry pi 3 Linux Device Driver\n下載上課用Raspberry Pi image檔 (Linux 核心 4.14.x )(已包含上課用的範例程式 最新版本請再次下載)\nRaspberry Pi image\n範例程式\n登入帳號 派 密碼: 樹莓派\n程式目錄結構\ncd /home/pi/LinuxDriver_Data_20191001\n├── Code\n├── 01_LED\r├── 02_BTN_LED\r├── ....\r├── driver-example\r├── hello\r├── image_Readme.txt \u0026lt;== 請參考此檔案說明\n└── Sch\u0026amp;DataSheet\n說明\n1.範例程式碼是基於Linux 核心 4.14.x 版本。提醒: 來自核心所提供的Driver Code, 大部份都位於 linux-raspberrypi-kernel_1.20190401-1/drivers/bcma , 例如 driver_gpio.c (舊版是 arch/mach-bcm2708/bcm2708_gpio.c )\n2.講師講解內容不限於Raspberry Pi 開發套件包，惟能實際硬體實驗的部份會受限於Raspberry Pi 開發套件包所提供的硬體。 Raspberry Pi 開發套件包\n3.Linux Driver 學習須知\n如何執行第一個LED範例\n如何使用make menuconfig\nPi 新手教學(零) \u0026ndash;艾鍗Raspberry Pi I/O Shield 規格介紹： https://goo.gl/eg1JMh\nPi 新手教學(一) \u0026ndash; 使用Wind32 Disk Imager 燒錄卬象檔： https://goo.gl/bsxy66\nPi 新手教學(二) \u0026ndash;如何使用UART Console 登入Raspberry Pi： https://goo.gl/ffJ6aP\nPi 新手教學(三) \u0026ndash;使用SSH登入Raspberry Pi： https://goo.gl/KPGco1\n下載Pi子卡Datasheet及電路圖： https://goo.gl/FoDXM1\n","permalink":"https://weizongchen.github.io/blog/pi3ldd/","tags":["raspberry pi","linux"],"title":"pi3ldd"},{"categories":["說明文件"],"contents":"\n原因是這裡可能空白 至少要選一個\n","permalink":"https://weizongchen.github.io/blog/error_flash_download_failed_cortex-m0/","tags":["Tool"],"title":"Error:Flash Download failed - Cortex-M0"},{"categories":["說明文件"],"contents":"開啟 Option Define 好 DEBUG_ENABLE_SEMIHOST 在 Debug Mode 的時候打開 UART #1 可以看到 UART0 的輸出 ","permalink":"https://weizongchen.github.io/blog/debug_enable_semihost/","tags":["Tool"],"title":"SemiHost 使用方法"},{"categories":["說明文件"],"contents":"找M460開發版的2根空的 I2C 由上圖可以知道 I2C Pin角選\nPA5 SCL 板上 PIN75\nPA4 SDA 板上 PIN76\nBSP 包 直接用 I2C_MultiBytes_Master /* Slave address */\ng_u8DeviceAddr = 0x46;\nBH1750的 ID 是 0x46 (包含第8個 bit)\nI2C_WriteByte(I2C0, device ID (不包含第8個bit), 要傳的命令)\nI2C_WriteByte(I2C0, 0x23, 0x10);\n這裡命令 0x10 是參考下圖\n//I2C_ReadByte(I2C0, device ID (不包含第8個bit));\n//r = I2C_ReadByte(I2C0, 0x23);\n讀到幾個byte = I2C_ReadMultiBytes(I2C0, device ID 不包含第8個bit, 放個陣列ReadData 會存到回到ReadData, 讀取長度len = 2 )\nreceive_byte = I2C_ReadMultiBytes(I2C0, 0x23, ReadData, 2);\nLA 量測結果 我MCU發送 0x46 (第8bit 值0 方向 write) ID ，並給值 0x10 給 Device\n0x46+1 (第8bit 值1 方向 read)Device 回 MCU 2個值 : 0x00 0xC5\n實體接線 /**************************************************************************//**\r* @file main.c\r* @version V3.00\r* @brief\r* Show how to set I2C use Multi bytes API Read and Write data to Slave.\r* Needs to work with I2C_Slave sample code.\r* @copyright (C) 2021 Nuvoton Technology Corp. All rights reserved.\r*****************************************************************************/\r#include \u0026lt;stdio.h\u0026gt;\r#include \u0026#34;NuMicro.h\u0026#34;\r#define PLL_CLOCK 192000000\r/*---------------------------------------------------------------------------------------------------------*/\r/* Global variables */\r/*---------------------------------------------------------------------------------------------------------*/\rvolatile uint8_t g_u8DeviceAddr;\rvolatile uint8_t g_au8MstTxData[3];\rvolatile uint8_t g_u8MstRxData;\rvolatile uint8_t g_u8MstDataLen;\rvolatile uint8_t g_u8MstEndFlag = 0;\rtypedef void (*I2C_FUNC)(uint32_t u32Status);\rvolatile static I2C_FUNC s_I2C0HandlerFn = NULL;\rvoid SYS_Init(void)\r{\r/*---------------------------------------------------------------------------------------------------------*/\r/* Init System Clock */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Set PCLK0 and PCLK1 to HCLK/2 */\rCLK-\u0026gt;PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);\r/* Set core clock to 200MHz */\rCLK_SetCoreClock(200000000);\r/* Enable all GPIO clock */\rCLK-\u0026gt;AHBCLK0 |= CLK_AHBCLK0_GPACKEN_Msk | CLK_AHBCLK0_GPBCKEN_Msk | CLK_AHBCLK0_GPCCKEN_Msk | CLK_AHBCLK0_GPDCKEN_Msk |\rCLK_AHBCLK0_GPECKEN_Msk | CLK_AHBCLK0_GPFCKEN_Msk | CLK_AHBCLK0_GPGCKEN_Msk | CLK_AHBCLK0_GPHCKEN_Msk;\rCLK-\u0026gt;AHBCLK1 |= CLK_AHBCLK1_GPICKEN_Msk | CLK_AHBCLK1_GPJCKEN_Msk;\r/* Enable UART0 module clock */\rCLK_EnableModuleClock(UART0_MODULE);\r/* Select UART0 module clock source as HIRC and UART0 module clock divider as 1 */\rCLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HIRC, CLK_CLKDIV0_UART0(1));\r/* Enable I2C0 peripheral clock */\rCLK_EnableModuleClock(I2C0_MODULE);\r/*---------------------------------------------------------------------------------------------------------*/\r/* Init I/O Multi-function */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Set multi-function pins for UART0 RXD and TXD */\rSET_UART0_RXD_PB12();\rSET_UART0_TXD_PB13();;\r/* Set I2C0 multi-function pins */\rSET_I2C0_SDA_PA4();\rSET_I2C0_SCL_PA5();\r/* I2C pin enable schmitt trigger */\rPA-\u0026gt;SMTEN |= GPIO_SMTEN_SMTEN4_Msk | GPIO_SMTEN_SMTEN5_Msk;\r}\rvoid I2C0_Init(void)\r{\r/* Open I2C module and set bus clock */\rI2C_Open(I2C0, 100000);\r/* Get I2C0 Bus Clock */\rprintf(\u0026#34;I2C clock %d Hz\\n\u0026#34;, I2C_GetBusClockFreq(I2C0));\r}\rvoid I2C0_Close(void)\r{\r/* Disable I2C0 interrupt and clear corresponding NVIC bit */\rI2C_DisableInt(I2C0);\rNVIC_DisableIRQ(I2C0_IRQn);\r/* Disable I2C0 and close I2C0 clock */\rI2C_Close(I2C0);\rCLK_DisableModuleClock(I2C0_MODULE);\r}\rint32_t main(void)\r{\ruint32_t receive_byte;\ruint8_t ReadData[2];\ruint32_t Lux;\ruint32_t i;\ruint8_t txbuf[256] = {0}, rDataBuf[256] = {0};\r/* Unlock protected registers */\rSYS_UnlockReg();\r/* Init System, IP clock and multi-function I/O. */\rSYS_Init();\r/* Configure UART0: 115200, 8-bit word, no parity bit, 1 stop bit. */\rUART_Open(UART0, 115200);\r#ifdef _PZ\r/* For palladium */\rUART0-\u0026gt;BAUD = UART_BAUD_MODE2 | UART_BAUD_MODE2_DIVIDER(153600, 38400);\r#endif\r/*\rThis sample code sets I2C bus clock to 100kHz. Then, Master accesses Slave with Multi Bytes Write\rand Multi Bytes Read operations, and check if the read data is equal to the programmed data.\r*/\rprintf(\u0026#34;+--------------------------------------------------------+\\n\u0026#34;);\rprintf(\u0026#34;| I2C Driver Sample Code for Multi Bytes Read/Write Test |\\n\u0026#34;);\rprintf(\u0026#34;| Needs to work with I2C_Slave sample code |\\n\u0026#34;);\rprintf(\u0026#34;| |\\n\u0026#34;);\rprintf(\u0026#34;| I2C Master (I2C0) \u0026lt;---\u0026gt; I2C Slave(I2C0) |\\n\u0026#34;);\rprintf(\u0026#34;| !! This sample code requires two borads to test !! |\\n\u0026#34;);\rprintf(\u0026#34;+--------------------------------------------------------+\\n\u0026#34;);\rprintf(\u0026#34;\\n\u0026#34;);\r/* Init I2C0 */\rI2C0_Init();\r/* Slave address */\rg_u8DeviceAddr = 0x46;\rI2C_WriteByte(I2C0, 0x23, 0x10);\r//r = I2C_ReadByte(I2C0, 0x23);\rreceive_byte = I2C_ReadMultiBytes(I2C0, 0x23, ReadData, 2);\rprintf(\u0026#34;receive_byte = %d \\n\u0026#34;, receive_byte);\rprintf(\u0026#34;ReadData[0] = %x \\n\u0026#34;, ReadData[0]);\rprintf(\u0026#34;ReadData[1] = %x \\n\u0026#34;, ReadData[1]);\rLux = ReadData[0] * 256 + ReadData[1];\rwhile(1)\r{\rI2C_ReadMultiBytes(I2C0, 0x23, ReadData, 2);\rLux = ReadData[0] * 256 + ReadData[1];\rprintf(\u0026#34;Lux = %d \\n\u0026#34;, Lux);\r}\r}\r/*** (C) COPYRIGHT 2021 Nuvoton Technology Corp. ***/ ","permalink":"https://weizongchen.github.io/blog/i2c_bh1750/","tags":["Cortex M4"],"title":"使用M460開發版的 I2C 去要 BH1750 照度計sensor的data"},{"categories":["說明文件"],"contents":"BSP EPWM 我是找 BSP 使用的 PWM PIN 角， 但還是用pinconfigure 看一下\n所以根據上圖以及BSP ，\nPWM1 的 Channel0\n會發訊號 給\nPWM1 的 Channel2\n查看開發版的電路圖 是哪兩根PIN EPWM_Capture BSP 的 console 量測邏輯分析儀 EPWM1 的 channel0 發 250 Hz pwm 訊號 30% duty\n/**************************************************************************//**\r* @file main.c\r* @version V3.00\r* @brief Capture the EPWM1 Channel 0 waveform by EPWM1 Channel 2.\r*\r* @copyright SPDX-License-Identifier: Apache-2.0\r* @copyright Copyright (C) 2021 Nuvoton Technology Corp. All rights reserved.\r******************************************************************************/\r#include \u0026lt;stdio.h\u0026gt;\r#include \u0026#34;NuMicro.h\u0026#34;\r/*---------------------------------------------------------------------------------------------------------*/\r/* Macro, type and constant definitions */\r/*---------------------------------------------------------------------------------------------------------*/\r/*---------------------------------------------------------------------------------------------------------*/\r/* Global variables */\r/*---------------------------------------------------------------------------------------------------------*/\rvoid CalPeriodTime(EPWM_T *EPWM, uint32_t u32Ch);\rvoid SYS_Init(void);\rvoid UART0_Init(void);\r/*--------------------------------------------------------------------------------------*/\r/* Capture function to calculate the input waveform information */\r/* au32Count[4] : Keep the internal counter value when input signal rising / falling */\r/* happens */\r/* */\r/* time A B C D */\r/* ___ ___ ___ ___ ___ ___ ___ ___ */\r/* ____| |_| |_| |_| |_| |_| |_| |_| |_____ */\r/* index 0 1 2 3 */\r/* */\r/* The capture internal counter down count from 0x10000, and reload to 0x10000 after */\r/* input signal falling happens (Time B/C/D) */\r/*--------------------------------------------------------------------------------------*/\rvoid CalPeriodTime(EPWM_T *EPWM, uint32_t u32Ch)\r{\ruint16_t au16Count[4];\ruint32_t u32i;\ruint16_t u16RisingTime, u16FallingTime, u16HighPeriod, u16LowPeriod, u16TotalPeriod;\r/* Clear Capture Falling Indicator (Time A) */\rEPWM_ClearCaptureIntFlag(EPWM, u32Ch, EPWM_CAPTURE_INT_FALLING_LATCH);\r/* Wait for Capture Falling Indicator */\rwhile((EPWM1-\u0026gt;CAPIF \u0026amp; EPWM_CAPIF_CFLIF2_Msk) == 0);\r/* Clear Capture Falling Indicator (Time B)*/\rEPWM_ClearCaptureIntFlag(EPWM, u32Ch, EPWM_CAPTURE_INT_FALLING_LATCH);\ru32i = 0;\rwhile(u32i \u0026lt; 4)\r{\r/* Wait for Capture Falling Indicator */\rwhile(EPWM_GetCaptureIntFlag(EPWM, u32Ch) \u0026lt; 2);\r/* Clear Capture Falling and Rising Indicator */\rEPWM_ClearCaptureIntFlag(EPWM, u32Ch, EPWM_CAPTURE_INT_FALLING_LATCH | EPWM_CAPTURE_INT_RISING_LATCH);\r/* Get Capture Falling Latch Counter Data */\rau16Count[u32i++] = (uint16_t)EPWM_GET_CAPTURE_FALLING_DATA(EPWM, u32Ch);\r/* Wait for Capture Rising Indicator */\rwhile(EPWM_GetCaptureIntFlag(EPWM, u32Ch) \u0026lt; 2);\r/* Clear Capture Rising Indicator */\rEPWM_ClearCaptureIntFlag(EPWM, u32Ch, EPWM_CAPTURE_INT_RISING_LATCH);\r/* Get Capture Rising Latch Counter Data */\rau16Count[u32i++] = (uint16_t)EPWM_GET_CAPTURE_RISING_DATA(EPWM, u32Ch);\r}\ru16RisingTime = au16Count[1];\ru16FallingTime = au16Count[0];\ru16HighPeriod = au16Count[1] - au16Count[2];\ru16LowPeriod = (uint16_t)(0x10000 - au16Count[1]);\ru16TotalPeriod = (uint16_t)(0x10000 - au16Count[2]);\rprintf(\u0026#34;\\nEPWM generate: \\nHigh Period=17141 ~ 17143, Low Period=39999 ~ 40001, Total Period=57141 ~ 57143\\n\u0026#34;);\rprintf(\u0026#34;\\nCapture Result: Rising Time = %d, Falling Time = %d \\nHigh Period = %d, Low Period = %d, Total Period = %d.\\n\\n\u0026#34;,\ru16RisingTime, u16FallingTime, u16HighPeriod, u16LowPeriod, u16TotalPeriod);\rif((u16HighPeriod \u0026lt; 17141) || (u16HighPeriod \u0026gt; 17143) || (u16LowPeriod \u0026lt; 39999) || (u16LowPeriod \u0026gt; 40001) || (u16TotalPeriod \u0026lt; 57141) || (u16TotalPeriod \u0026gt; 57143))\rprintf(\u0026#34;Capture Test Fail!!\\n\u0026#34;);\relse\rprintf(\u0026#34;Capture Test Pass!!\\n\u0026#34;);\r}\rvoid SYS_Init(void)\r{\r/* Set PF multi-function pins for XT1_OUT(PF.2) and XT1_IN(PF.3) */\rSET_XT1_OUT_PF2();\rSET_XT1_IN_PF3();\r/*---------------------------------------------------------------------------------------------------------*/\r/* Init System Clock */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Enable HIRC and HXT clock */\rCLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk | CLK_PWRCTL_HXTEN_Msk);\r/* Wait for HIRC and HXT clock ready */\rCLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk | CLK_STATUS_HXTSTB_Msk);\r/* Set PCLK0 and PCLK1 to HCLK/2 */\rCLK-\u0026gt;PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);\r/* Set core clock to 200MHz */\rCLK_SetCoreClock(200000000);\r/* Enable all GPIO clock */\rCLK-\u0026gt;AHBCLK0 |= CLK_AHBCLK0_GPACKEN_Msk | CLK_AHBCLK0_GPBCKEN_Msk | CLK_AHBCLK0_GPCCKEN_Msk | CLK_AHBCLK0_GPDCKEN_Msk |\rCLK_AHBCLK0_GPECKEN_Msk | CLK_AHBCLK0_GPFCKEN_Msk | CLK_AHBCLK0_GPGCKEN_Msk | CLK_AHBCLK0_GPHCKEN_Msk;\rCLK-\u0026gt;AHBCLK1 |= CLK_AHBCLK1_GPICKEN_Msk | CLK_AHBCLK1_GPJCKEN_Msk;\r/* Enable UART0 module clock */\rCLK_EnableModuleClock(UART0_MODULE);\r/* Select UART0 module clock source as HIRC and UART0 module clock divider as 1 */\rCLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HIRC, CLK_CLKDIV0_UART0(1));\r/* Enable EPWM1 module clock */\rCLK_EnableModuleClock(EPWM1_MODULE);\r/* Select EPWM1 module clock source */\rCLK_SetModuleClock(EPWM1_MODULE, CLK_CLKSEL2_EPWM1SEL_PCLK1, 0);\r/*---------------------------------------------------------------------------------------------------------*/\r/* Init I/O Multi-function */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Set multi-function pins for UART0 RXD and TXD */\rSET_UART0_RXD_PB12();\rSET_UART0_TXD_PB13();\r/* Set multi-function pin for EPWM */\rSET_EPWM1_CH0_PC5();\rSET_EPWM1_CH2_PC3();\r}\rvoid UART0_Init(void)\r{\r/*---------------------------------------------------------------------------------------------------------*/\r/* Init UART */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Configure UART0 and set UART0 baud rate */\rUART_Open(UART0, 115200);\r}\r/*---------------------------------------------------------------------------------------------------------*/\r/* Main Function */\r/*---------------------------------------------------------------------------------------------------------*/\rint32_t main(void)\r{\r/* Init System, IP clock and multi-function I/O\rIn the end of SYS_Init() will issue SYS_LockReg()\rto lock protected register. If user want to write\rprotected register, please issue SYS_UnlockReg()\rto unlock protected register if necessary */\r/* Unlock protected registers */\rSYS_UnlockReg();\r/* Init System, IP clock and multi-function I/O */\rSYS_Init();\r/* Lock protected registers */\rSYS_LockReg();\r/* Init UART to 115200-8n1 for print message */\rUART0_Init();\rprintf(\u0026#34;\\n\\nCPU @ %dHz(PLL@ %dHz)\\n\u0026#34;, SystemCoreClock, PllClock);\rprintf(\u0026#34;+------------------------------------------------------------------------+\\n\u0026#34;);\rprintf(\u0026#34;| EPWM Driver Sample Code |\\n\u0026#34;);\rprintf(\u0026#34;| |\\n\u0026#34;);\rprintf(\u0026#34;+------------------------------------------------------------------------+\\n\u0026#34;);\rprintf(\u0026#34; This sample code will use EPWM1 channel 2 to capture\\n the signal from EPWM1 channel 0.\\n\u0026#34;);\rprintf(\u0026#34; I/O configuration:\\n\u0026#34;);\rprintf(\u0026#34; EPWM1 channel 2(PC.3) \u0026lt;--\u0026gt; EPWM1 channel 0(PC.5)\\n\\n\u0026#34;);\rprintf(\u0026#34;Use EPWM1 Channel 2(PC.3) to capture the EPWM1 Channel 0(PC.5) Waveform\\n\u0026#34;);\rwhile(1)\r{\rprintf(\u0026#34;\\n\\nPress any key to start EPWM Capture Test\\n\u0026#34;);\rgetchar();\r/*--------------------------------------------------------------------------------------*/\r/* Set the EPWM1 Channel 0 as EPWM output function. */\r/*--------------------------------------------------------------------------------------*/\r/* Assume EPWM output frequency is 250Hz and duty ratio is 30%, user can calculate EPWM settings by follows.(up counter type)\rduty ratio = (CMR)/(CNR+1)\rcycle time = CNR+1\rHigh level = CMR\rEPWM clock source frequency = PLL/2 = 100000000\r(CNR+1) = EPWM clock source frequency/prescaler/EPWM output frequency\r= 100000000/7/250 = 57142\r(Note: CNR is 16 bits, so if calculated value is larger than 65536, user should increase prescale value.)\rCNR = 57141\rduty ratio = 30% ==\u0026gt; (CMR)/(CNR+1) = 30%\rCMR = 17142\rPrescale value is 6 : prescaler= 7\r*/\r/* Set EPWM1 channel 0 output configuration */\rEPWM_ConfigOutputChannel(EPWM1, 0, 250, 30);\r/* Enable EPWM Output path for EPWM1 channel 0 */\rEPWM_EnableOutput(EPWM1, EPWM_CH_0_MASK);\r/* Enable Timer for EPWM1 channel 0 */\rEPWM_Start(EPWM1, EPWM_CH_0_MASK);\r/*--------------------------------------------------------------------------------------*/\r/* Set the EPWM1 channel 2 for capture function */\r/*--------------------------------------------------------------------------------------*/\r/* If input minimum frequency is 250Hz, user can calculate capture settings by follows.\rCapture clock source frequency = PLL = 100000000 in the sample code.\r(CNR+1) = Capture clock source frequency/prescaler/minimum input frequency\r= 100000000/7/250 = 57142\r(Note: CNR is 16 bits, so if calculated value is larger than 65536, user should increase prescale value.)\rCNR = 0xFFFF\r(Note: In capture mode, user should set CNR to 0xFFFF to increase capture frequency range.)\rCapture unit time = 1/Capture clock source frequency/prescaler\r70 ns = 1/100000000/7\r*/\r/* Set EPWM1 channel 2 capture configuration */\rEPWM_ConfigCaptureChannel(EPWM1, 2, 70, 0);\r/* Enable Timer for EPWM1 channel 2 */\rEPWM_Start(EPWM1, EPWM_CH_2_MASK);\r/* Enable Capture Function for EPWM1 channel 2 */\rEPWM_EnableCapture(EPWM1, EPWM_CH_2_MASK);\r/* Enable falling capture reload */\rEPWM1-\u0026gt;CAPCTL |= EPWM_CAPCTL_FCRLDEN2_Msk;\r/* Wait until EPWM1 channel 2 Timer start to count */\rwhile((EPWM1-\u0026gt;CNT[2]) == 0);\r/* Capture the Input Waveform Data */\rCalPeriodTime(EPWM1, 2);\r/*------------------------------------------------------------------------------------------------------------*/\r/* Stop EPWM1 channel 0 (Recommended procedure method 1) */\r/* Set EPWM Timer loaded value(Period) as 0. When EPWM internal counter(CNT) reaches to 0, disable EPWM Timer */\r/*------------------------------------------------------------------------------------------------------------*/\r/* Set EPWM1 channel 0 loaded value as 0 */\rEPWM_Stop(EPWM1, EPWM_CH_0_MASK);\r/* Wait until EPWM1 channel 0 Timer Stop */\rwhile((EPWM1-\u0026gt;CNT[0] \u0026amp; EPWM_CNT0_CNT_Msk) != 0);\r/* Disable Timer for EPWM1 channel 0 */\rEPWM_ForceStop(EPWM1, EPWM_CH_0_MASK);\r/* Disable EPWM Output path for EPWM1 channel 0 */\rEPWM_DisableOutput(EPWM1, EPWM_CH_0_MASK);\r/*------------------------------------------------------------------------------------------------------------*/\r/* Stop EPWM1 channel 2 (Recommended procedure method 1) */\r/* Set EPWM Timer loaded value(Period) as 0. When EPWM internal counter(CNT) reaches to 0, disable EPWM Timer */\r/*------------------------------------------------------------------------------------------------------------*/\r/* Set loaded value as 0 for EPWM1 channel 2 */\rEPWM_Stop(EPWM1, EPWM_CH_2_MASK);\r/* Wait until EPWM1 channel 2 current counter reach to 0 */\rwhile((EPWM1-\u0026gt;CNT[2] \u0026amp; EPWM_CNT2_CNT_Msk) != 0);\r/* Disable Timer for EPWM1 channel 2 */\rEPWM_ForceStop(EPWM1, EPWM_CH_2_MASK);\r/* Disable Capture Function and Capture Input path for EPWM1 channel 2*/\rEPWM_DisableCapture(EPWM1, EPWM_CH_2_MASK);\r/* Clear Capture Interrupt flag for EPWM1 channel 2 */\rEPWM_ClearCaptureIntFlag(EPWM1, 2, EPWM_CAPTURE_INT_FALLING_LATCH);\r}\r}\r/*** (C) COPYRIGHT 2021 Nuvoton Technology Corp. ***/ ","permalink":"https://weizongchen.github.io/blog/pwm/","tags":["Cortex M4"],"title":" PWM 的 應用範例 "},{"categories":["說明文件"],"contents":"Timer0 電路位置 由pinconfigure 可以知道Timer0 在 pin 1 (PB5) 接著\n設定 Timer0 pin 角 //\u0026mdash;PIN\u0026mdash;- /* Set timer toggle out pin */ SET_TM0_PB5();\nTimer Delay Delay 1 秒:\nTIMER_Delay(TIMER0, 1000000);\nTimer init_TIMER0_Toggle TIMER_Open(TIMER0, TIMER_TOGGLE_MODE, 250000);\n開啟TIMER0 反轉250K\n邏輯分析儀量測 邏輯分析儀 桶著 Pin1 開 Salease 邏輯分析儀 SW 可以發現訊號是125K Hz 波峰 +波谷 就250K Hz\n/*---------------------------------------------------------------------------------------------------------*/\r/* Global Interface Variables Declarations */\r/*---------------------------------------------------------------------------------------------------------*/\rvolatile uint32_t g_au32TMRINTCount[4] = {0};\r//----------------- TIMER0 --------------------\rvoid TMR0_IRQHandler(void)\r{\rif(TIMER_GetIntFlag(TIMER0) == 1)\r{\r/* Clear Timer0 time-out interrupt flag */\rTIMER_ClearIntFlag(TIMER0);\rg_au32TMRINTCount[0]++;\rPH4 ^= 1;\r}\r}\rvoid TMR0_Init(void)\r{\r/* Enable TIMER module clock */\r//---clock---\rCLK_EnableModuleClock(TMR0_MODULE);\rCLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_HXT, 0);\r//---PIN----\r/* Set timer toggle out pin */\rSET_TM0_PB5();\r/* Open Timer0 in periodic mode, enable interrupt and 1 interrupt tick per second */\rTIMER_Open(TIMER0, TIMER_PERIODIC_MODE, 1);\r/* Start Timer0 ~ Timer3 counting */\rTIMER_Start(TIMER0);\r//--- NVIC ----\rTIMER_EnableInt(TIMER0);\r/* Enable Timer0 ~ Timer3 NVIC */\rNVIC_EnableIRQ(TMR0_IRQn);\r/* Check Timer0 ~ Timer3 interrupt counts */\r//g_au32TMRINTCount[0];\r}\rvoid init_TIMER0_Toggle(void)\r{\r/* Enable TIMER module clock */\r//---clock---\rCLK_EnableModuleClock(TMR0_MODULE);\rCLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_HXT, 0);\r//---PIN----\r/* Set timer toggle out pin */\rSET_TM0_PB5();\r/* Open Timer0 in periodic mode, enable interrupt and 1 interrupt tick per second */\rTIMER_Open(TIMER0, TIMER_TOGGLE_MODE, 250000);\r/* Start Timer0 ~ Timer3 counting */\rTIMER_Start(TIMER0);\r}\r//-------------- HCLK -------------\rvoid init_HCLK(void){\rSYS_UnlockReg();\r/*---------------------------------------------------------------------------------------------------------*/\r/* Init System Clock */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Set PCLK0 and PCLK1 to HCLK/2 */\rCLK-\u0026gt;PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);\r/* Set core clock to 200MHz */\rCLK_SetCoreClock(200000000);\r/* Enable all GPIO clock */\rCLK-\u0026gt;AHBCLK0 |= CLK_AHBCLK0_GPACKEN_Msk | CLK_AHBCLK0_GPBCKEN_Msk | CLK_AHBCLK0_GPCCKEN_Msk | CLK_AHBCLK0_GPDCKEN_Msk |\rCLK_AHBCLK0_GPECKEN_Msk | CLK_AHBCLK0_GPFCKEN_Msk | CLK_AHBCLK0_GPGCKEN_Msk | CLK_AHBCLK0_GPHCKEN_Msk;\rCLK-\u0026gt;AHBCLK1 |= CLK_AHBCLK1_GPICKEN_Msk | CLK_AHBCLK1_GPJCKEN_Msk;\r/* Enable HXT clock */\rCLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);\rCLK_WaitClockReady( CLK_STATUS_HXTSTB_Msk);\rSYS_LockReg();\r}\r/*---------------------------------------------------------------------------------------------------------*/\r/* Main Function */\r/*---------------------------------------------------------------------------------------------------------*/\rint32_t main(void)\r{\ruint16_t cnt = 0;\ruint8_t STA = 0;\r/* Unlock protected registers */\rSYS_UnlockReg();\r/* Init System, peripheral clock and multi-function I/O */\rSYS_Init();\r/* Lock protected registers */\rSYS_LockReg();\r/* Init UART0 for printf */\rUART0_Init();\rinit_HCLK();\rinit_TIMER0_Toggle();\r// PH4 LED R\rGPIO_SetMode(PH, BIT4, GPIO_MODE_OUTPUT);\rwhile(1) {\r}\r} ","permalink":"https://weizongchen.github.io/blog/timer_init_timer0_toggle/","tags":["Cortex M4"],"title":"Timer Toggle 使用邏輯分析儀量測timer toggle (by M460)"},{"categories":["說明文件"],"contents":" 新唐 Pinconfigure 地址 https://www.nuvoton.com/resource-download.jsp?tp_GUID=SW1320200319135912\n當發現我要的IC 沒有出現在 我要的M460 沒有在 Pinconfigure 選單\nDownload 新的exe file Pinconfigure 下載\nM460 出現了 ","permalink":"https://weizongchen.github.io/blog/install_and_update_pinconfigure/","tags":["Tool"],"title":"安裝新唐 Pinconfigure "},{"categories":["說明文件"],"contents":"Button 的 狀態討論 /*---------------------------------------------------------------------------------------------------------*/\r/* Main Function */\r/*---------------------------------------------------------------------------------------------------------*/\rint32_t main(void)\r{\ruint16_t cnt = 0;\ruint8_t STA = 0;\r/* Unlock protected registers */\rSYS_UnlockReg();\r/* Init System, peripheral clock and multi-function I/O */\rSYS_Init();\r/* Lock protected registers */\rSYS_LockReg();\r/* Init UART0 for printf */\rUART0_Init();\rwhile(1) {\rSTA \u0026lt;\u0026lt;= 1;\rSTA += PH0;\rprintf(\u0026#34;%d \\n\u0026#34;, PH0);\rTIMER_Delay(TIMER0, 1000000);\rSTA \u0026amp;= 3;\rif(STA == 2) {\rcnt++;\r//printf(\u0026#34;%d \u0026#34;, cnt);\r}\r//TIMER_Delay(TIMER0, 1000000);\r}\r} STA 原始值 00000000(0)\n二進制 (十進制)\rSTA :\n第一圈 結果 00000000 左移一次 00000000 00000000+ PH0(1) [沒有按] 00000001 00000001 \u0026amp; 00000011(3) 00000001(1) STA == 2 false 第二圈 結果 00000001 左移一次 00000010 00000010 + PH0(1) [沒有按] 00000011 00000011 \u0026amp; 00000011(3) 00000011(3) STA == 2 false 第三圈 結果 00000011 左移一次 00000110 00000110 + PH0(1) [沒有按] 00000111 00000111 \u0026amp; 00000011(3) 00000011(3) STA == 2 false 第四圈 結果 00000011 左移一次 00000110 00000110 + PH0(1) [沒有按] 00000111 00000111 \u0026amp; 00000011(3) 00000011(3) STA == 2 false 第五圈 結果 00000011 左移一次 00000110 00000110 + PH0(0) [按下去] 00000110 00000110 \u0026amp; 00000011(3) 00000010(2) STA == 2 true 印數字 (CPU執行很快，可能不小心print到數個數字)\n第六圈 結果 00000010 左移一次 00000100 00000100 + PH0(0) [還按著] 00000100 00000100 \u0026amp; 00000011(3) 00000000(0) STA == 2 false 第七圈 結果 00000000 左移一次 00000000 00000000 + PH0(0) [還按著] 00000000 00000000 \u0026amp; 00000011(3) 00000000(0) STA == 2 false 第八圈 (等於第一圈) 結果 00000000 左移一次 00000000 00000000 + PH0(1) [沒有按] 00000001 00000001 \u0026amp; 00000011(3) 00000001(1) STA == 2 false ","permalink":"https://weizongchen.github.io/blog/btn/","tags":["Cortex M4"],"title":"Button 的各種說明"},{"categories":["說明文件"],"contents":"加入Timer的Driver 在 SYS_Init() 時 ，加入TMR0 的 clock source /*---------------------------------------------------------------------------------------------------------*/\r/* Initialization for sample code */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Enable TIMER module clock */\rCLK_EnableModuleClock(TMR0_MODULE);\r/* Select TIMER clock source */\rCLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_HIRC, 0); 在 SYS_Init() 時 ，加入TMR0 的 clock source while(1) {\rPH4 = 1;\rTIMER_Delay(TIMER0, 1000000);\rPH4 = 0;\rTIMER_Delay(TIMER0, 1000000);\r} 邏輯分析儀量測 LED 訊號 用 Timer0 控制 LED 1秒亮 1秒滅 /**************************************************************************//**\r* @file main.c\r* @version V3.00\r* @brief Transmit and receive data from PC terminal through RS232 interface.\r*\r* @copyright SPDX-License-Identifier: Apache-2.0\r* @copyright Copyright (C) 2021 Nuvoton Technology Corp. All rights reserved.\r******************************************************************************/\r#include \u0026lt;stdio.h\u0026gt;\r#include \u0026#34;NuMicro.h\u0026#34;\r#define RXBUFSIZE 1024\r/*---------------------------------------------------------------------------------------------------------*/\r/* Global variables */\r/*---------------------------------------------------------------------------------------------------------*/\rstatic uint8_t g_u8RecData[RXBUFSIZE] = {0};\rstatic volatile uint32_t g_u32comRbytes = 0;\rstatic volatile uint32_t g_u32comRhead = 0;\rstatic volatile uint32_t g_u32comRtail = 0;\rstatic volatile int32_t g_i32Wait = TRUE;\r/*---------------------------------------------------------------------------------------------------------*/\r/* Define functions prototype */\r/*---------------------------------------------------------------------------------------------------------*/\rint32_t main(void);\rvoid UART_TEST_HANDLE(void);\rvoid UART_FunctionTest(void);\rvoid SYS_Init(void);\rvoid UART0_Init(void);\rvoid UART0_IRQHandler(void);\rvoid SYS_Init(void)\r{\r/*---------------------------------------------------------------------------------------------------------*/\r/* Init System Clock */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Set PCLK0 and PCLK1 to HCLK/2 */\rCLK-\u0026gt;PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);\r/* Set core clock to 200MHz */\rCLK_SetCoreClock(200000000);\r/* Enable all GPIO clock */\rCLK-\u0026gt;AHBCLK0 |= CLK_AHBCLK0_GPACKEN_Msk | CLK_AHBCLK0_GPBCKEN_Msk | CLK_AHBCLK0_GPCCKEN_Msk | CLK_AHBCLK0_GPDCKEN_Msk |\rCLK_AHBCLK0_GPECKEN_Msk | CLK_AHBCLK0_GPFCKEN_Msk | CLK_AHBCLK0_GPGCKEN_Msk | CLK_AHBCLK0_GPHCKEN_Msk;\rCLK-\u0026gt;AHBCLK1 |= CLK_AHBCLK1_GPICKEN_Msk | CLK_AHBCLK1_GPJCKEN_Msk;\r/* Enable UART module clock */\rCLK_EnableModuleClock(UART0_MODULE);\rCLK_EnableModuleClock(UART1_MODULE);\r/* Select UART module clock source and UART module clock divider */\rCLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HIRC, CLK_CLKDIV0_UART0(1));\rCLK_SetModuleClock(UART1_MODULE, CLK_CLKSEL1_UART1SEL_HIRC, CLK_CLKDIV0_UART1(1));\r/*---------------------------------------------------------------------------------------------------------*/\r/* Init I/O Multi-function */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Set multi-function pins for UART0 RXD and TXD */\rSET_UART0_RXD_PB12();\rSET_UART0_TXD_PB13();\r/*---------------------------------------------------------------------------------------------------------*/\r/* Initialization for sample code */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Enable TIMER module clock */\rCLK_EnableModuleClock(TMR0_MODULE);\r/* Select TIMER clock source */\rCLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_HIRC, 0);\r}\rvoid UART0_Init(void)\r{\r/*---------------------------------------------------------------------------------------------------------*/\r/* Init UART */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Reset UART0 */\rSYS_ResetModule(UART0_RST);\r/* Configure UART0 and set UART0 baud rate */\rUART_Open(UART0, 115200);\r}\r/*---------------------------------------------------------------------------------------------------------*/\r/* Main Function */\r/*---------------------------------------------------------------------------------------------------------*/\rint32_t main(void)\r{\r/* Unlock protected registers */\rSYS_UnlockReg();\r/* Init System, peripheral clock and multi-function I/O */\rSYS_Init();\r/* Lock protected registers */\rSYS_LockReg();\r/* Init UART0 for printf */\rUART0_Init();\rGPIO_SetMode(PH, BIT4, GPIO_MODE_OUTPUT);\rprintf(\u0026#34;test \\n\u0026#34;);\rwhile(1) {\rPH4 = 1;\rTIMER_Delay(TIMER0, 1000000);\rPH4 = 0;\rTIMER_Delay(TIMER0, 1000000);\r}\r}\r/*---------------------------------------------------------------------------------------------------------*/\r/* ISR to handle UART Channel 0 interrupt event */\r/*---------------------------------------------------------------------------------------------------------*/\rvoid UART0_IRQHandler(void)\r{\rUART_TEST_HANDLE();\r}\r/*---------------------------------------------------------------------------------------------------------*/\r/* UART Callback function */\r/*---------------------------------------------------------------------------------------------------------*/\rvoid UART_TEST_HANDLE(void)\r{\ruint8_t u8InChar = 0xFF;\ruint32_t u32IntSts = UART0-\u0026gt;INTSTS;\rif(u32IntSts \u0026amp; UART_INTSTS_RDAINT_Msk)\r{\rprintf(\u0026#34;\\nInput:\u0026#34;);\r/* Get all the input characters */\rwhile(UART_IS_RX_READY(UART0))\r{\r/* Get the character from UART Buffer */\ru8InChar = (uint8_t)UART_READ(UART0);\rprintf(\u0026#34;%c \u0026#34;, u8InChar);\rif(u8InChar == \u0026#39;0\u0026#39;)\r{\rg_i32Wait = FALSE;\r}\r/* Check if buffer full */\rif(g_u32comRbytes \u0026lt; RXBUFSIZE)\r{\r/* Enqueue the character */\rg_u8RecData[g_u32comRtail] = u8InChar;\rg_u32comRtail = (g_u32comRtail == (RXBUFSIZE - 1)) ? 0 : (g_u32comRtail + 1);\rg_u32comRbytes++;\r}\r}\rprintf(\u0026#34;\\nTransmission Test:\u0026#34;);\r/* Forces a write of all user-space buffered data for the given output */\rfflush(stdout);\r}\rif(u32IntSts \u0026amp; UART_INTSTS_THREINT_Msk)\r{\ruint32_t u32Tmp;\ru32Tmp = g_u32comRtail;\rif(g_u32comRhead != u32Tmp)\r{\ru8InChar = g_u8RecData[g_u32comRhead];\rwhile(UART_IS_TX_FULL(UART0)); /* Wait Tx is not full to transmit data */\rUART_WRITE(UART0, u8InChar);\rg_u32comRhead = (g_u32comRhead == (RXBUFSIZE - 1)) ? 0 : (g_u32comRhead + 1);\rg_u32comRbytes--;\r}\r}\r/* Handle transmission error */\rif(UART0-\u0026gt;FIFOSTS \u0026amp; (UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk | UART_FIFOSTS_RXOVIF_Msk))\r{\rUART0-\u0026gt;FIFOSTS = (UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk | UART_FIFOSTS_RXOVIF_Msk);\r}\r}\r/*---------------------------------------------------------------------------------------------------------*/\r/* UART Function Test */\r/*---------------------------------------------------------------------------------------------------------*/\rvoid UART_FunctionTest(void)\r{\rprintf(\u0026#34;+-----------------------------------------------------------+\\n\u0026#34;);\rprintf(\u0026#34;| UART Function Test |\\n\u0026#34;);\rprintf(\u0026#34;+-----------------------------------------------------------+\\n\u0026#34;);\rprintf(\u0026#34;| Description : |\\n\u0026#34;);\rprintf(\u0026#34;| The sample code will print input char on terminal |\\n\u0026#34;);\rprintf(\u0026#34;| Please enter any to start (Press \u0026#39;0\u0026#39; to exit) |\\n\u0026#34;);\rprintf(\u0026#34;+-----------------------------------------------------------+\\n\u0026#34;);\r/*\rUsing a RS232 cable to connect UART0 and PC.\rUART0 is set to debug port. UART0 is enable RDA interrupt.\rWhen inputting char to terminal screen, RDA interrupt will happen and\rUART0 will print the received char on screen.\r*/\r/* Enable UART RDA and THRE interrupt */\rNVIC_EnableIRQ(UART0_IRQn);\rUART_EnableInt(UART0, (UART_INTEN_RDAIEN_Msk | UART_INTEN_THREIEN_Msk));\rwhile(g_i32Wait);\r/* Disable UART RDA and THRE interrupt */\rNVIC_DisableIRQ(UART0_IRQn);\rUART_DisableInt(UART0, (UART_INTEN_RDAIEN_Msk | UART_INTEN_THREIEN_Msk));\rg_i32Wait = TRUE;\r} ","permalink":"https://weizongchen.github.io/blog/timer_delay/","tags":["Cortex M4"],"title":"Timer Delay 說明 (by M460)"},{"categories":["說明文件"],"contents":"在Keil IDE 的 Debug Mode 時 Memory window data 突然不實時更新了?\n下圖 右邊的 Memory2 本來會一直更新，但是沒有?\n只要在 View下的 Periodic Window Update 打開就好\n如下影片操作\n","permalink":"https://weizongchen.github.io/blog/keil_debug_memoryupdate/","tags":["Cortex M4"],"title":"Keil IDE Debug Mode Memory window data not update?"},{"categories":["說明文件"],"contents":"Keil IDE 在啟動 project 時，會自己上網下載 一堆不是新唐的pack\n下圖看到時趕緊關掉，不然他會一直download 不是新唐的東西。\n這邊選\u0026quot;是\u0026quot; 跳過這裡\n這個時候，Keil會跟你說沒有這個M460的 pack 包，你如果不安裝 ，compile 也會過，但是每次打開Keil 會就跳出來，滿煩的。\n去新唐的官網，下載Driver 就可以解決這個問題了。\n新唐Driver 位置\nNu-Link_Keil_Driver_V3.09.7380r\n準備安裝\n這裡如果你不懂，就按照指示預設安裝路徑。\n這裡會出現這個視窗，是因為我原本就已經安裝過這個Driver，裡面有M480 NUC505 \u0026hellip; 一堆 但是不包含M460的部分，所以按\u0026quot;是\u0026quot;，就會更新成有包含460的\n這裡步驟就是安裝pack(Nuvoton device family pack)了 一路按\u0026quot;是\u0026quot; 就可以了\n他會把Nuvoton的pack都安裝\n因為我使用新唐的開發版，上面有Nu-Link2-Me 的燒錄器，所以當然也安裝一下它的driver，你如果是 J-Link 、U-Link 、巴拉巴拉Link\u0026hellip;，要自己安裝他們的Driver喔。\n安裝\n再次打開Project 就不會有那些警告視窗拉~\n","permalink":"https://weizongchen.github.io/blog/keil_import_pack/","tags":["Cortex M4"],"title":"Keil IDE 在啟動 project 時，會自己上網下載 一堆不是新唐的pack"},{"categories":["說明文件"],"contents":"如果你不是商業使用 !\n如果你不是商業使用 !\n如果你不是商業使用 !\n很重要所以說三次! 所以如果你是個人評估使用\nARM 對這個 MDK-Community 說明\n簡單說就是支援 : All microcontrollers based on Arm Cortex®-M processors\n你給他E mail 它就給你licence\n把上面 LIC 填到下面\n","permalink":"https://weizongchen.github.io/blog/keil_ide_licence/","tags":["Cortex M4"],"title":"Keil IDE 16K Code size 限制?"},{"categories":["說明文件"],"contents":" 可以直接來這邊下載 https://www.nuvoton.com/tool-and-software/debugger-and-programmer/mass-production-tool/\nICP Tool 新唐燒錄器適用於新唐NuMicro®微控制器的大量生產階段。基於靈活的設定與直觀的操作，使用者可全面掌握量產流程。\n選擇你的series\n如果你電腦插著很多個NuLnk 可以選，點選Radio Button時，那個被指定的NuLnk會閃閃閃閃閃~\n如果你電腦灌過ICP 軟體了，跟這板子原本的ICP版本不匹配，你可以更新，也可以不更新，一般我都直接不更新，反正可以燒就好。\n因為我是要把板子上的APROM的 firmware拿出來存，可以照下圖的方式點選\n最後成功存取\nFile Data 要燒進去板子的FW版本\nOn board flash 板子上面的FW版本\nOffline Flash 在燒入除錯器裡面的版本\n","permalink":"https://weizongchen.github.io/blog/icp_introduce/","tags":["Tool"],"title":"ICP 使用說明"},{"categories":["說明文件"],"contents":" User Manual https://www.nuvoton.com/export/resource-files/UM_NuMaker-ETM-M487_User_Manual_EN_Rev1.01.pdf\n通用 I/O (GPIO) 概述 M480 系列多達118 個通用I/O管腳和其他功能管腳共享，這取決於芯片的配置。 118個管腳分配在PA, PB, PC, PD, PE, PF, PG 和 PH這8個端口上。 PA, PB, PE和PG有16個管腳，PC，PD有15個管腳，PF，PH有12個管腳。每個管腳都是獨立的，都有相應的寄存器位來控制管腳功能模式與數據。\n1. 設定發電廠 (clock) 2. 設定 LED 的腳位 General Port 0~7 為 Low byte, 8~15 為 High byte 所以是Port H 的 0 1 2 是L，如下面黃色的標記\n設定 Port H 0 1 2 腳位為 output\n3. 設定 Button 的腳位 General Port 0~7 為 Low byte, 8~15 為 High byte 所以是Port B 的 15 是H , Port F 的 11 是H，如下面黃色的標記\n設定 Port B 15 和 Port F 11 腳位為 input\n4. 設定 UART0 的腳位 新唐大部分的M4 UART0 腳位是 PB12 RXD / PB13 TXD\n5. 設定中斷 這邊中斷就是用UART0 打印東西，和 toggle LED 的亮滅\n完整程式參考 /**************************************************************************//**\r* @file main.c\r* @version V3.00\r* @brief GPIO function for level1 training course\r*\r******************************************************************************/\r#include \u0026lt;stdio.h\u0026gt;\r#include \u0026#34;NuMicro.h\u0026#34;\r#define LED_R\tPH0\r#define LED_G\tPH1\r#define LED_B\tPH2\r#define LED_ON\t0\r#define LED_OFF\t1\rvolatile uint32_t sw1_int_cnt = 0;\rvolatile uint32_t sw2_int_cnt = 0;\rvoid SYS_Init(void)\r{\r/* Enable HXT clock (external XTAL 12MHz) */\rCLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);\r/* Wait for HXT clock ready */\rCLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);\r/* Enable LIRC clock */\rCLK_EnableXtalRC(CLK_PWRCTL_LIRCEN_Msk);\r/* Wait for LIRC clock ready */\rCLK_WaitClockReady(CLK_STATUS_LIRCSTB_Msk);\r/* Set core clock as PLL_CLOCK from PLL */\rCLK_SetCoreClock(FREQ_192MHZ);\r/* Set PCLK0/PCLK1 to HCLK/2 */\rCLK-\u0026gt;PCLKDIV = (CLK_PCLKDIV_PCLK0DIV2 | CLK_PCLKDIV_PCLK1DIV2);\r/* Enable module clock */\rCLK_EnableModuleClock(UART0_MODULE);\r/* Set module clock */\rCLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HXT, CLK_CLKDIV0_UART0(1));\r}\rvoid UART0_Init()\r{\r/* Set GPB multi-function pins to UART0 RXD and TXD */\rSYS-\u0026gt;GPB_MFPH = (SYS-\u0026gt;GPB_MFPH \u0026amp; ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk)) |\r(SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);\r/* Configure UART0 and set UART0 baud rate */\rUART_Open(UART0, 115200);\r}\rvoid LED_Init(void)\r{\r/* Set PH.0 ~ PH.2 to GPIO */\rSYS-\u0026gt;GPH_MFPL = (SYS-\u0026gt;GPH_MFPL \u0026amp; ~(SYS_GPH_MFPL_PH0MFP_Msk | SYS_GPH_MFPL_PH1MFP_Msk | SYS_GPH_MFPL_PH2MFP_Msk)) |\r(SYS_GPH_MFPL_PH0MFP_GPIO | SYS_GPH_MFPL_PH1MFP_GPIO | SYS_GPH_MFPL_PH2MFP_GPIO);\r/* Set PC.9 ~ PC.11 to GPIO output */\rGPIO_SetMode(PH, (BIT0 | BIT1 | BIT2), GPIO_MODE_OUTPUT);\r/* Let LED off after initialize */\rLED_R = LED_OFF;\rLED_G = LED_OFF;\rLED_B = LED_OFF;\r}\rvoid BTN_Init(void)\r{\r/************** SW2 ***************/\r/* Set PB.15 to GPIO */\rSYS-\u0026gt;GPG_MFPH = (SYS-\u0026gt;GPG_MFPH \u0026amp; ~(SYS_GPG_MFPH_PG15MFP_Msk)) | (SYS_GPG_MFPH_PG15MFP_GPIO);\r/* Set PB.15 to GPIO intput */\rGPIO_SetMode(PG, BIT15, GPIO_MODE_INPUT);\rGPIO_EnableInt(PG, 15, GPIO_INT_FALLING);\rNVIC_EnableIRQ(GPG_IRQn);\r/************** SW3 ***************/\r/* Set PF.11 to GPIO */\rSYS-\u0026gt;GPF_MFPH = (SYS-\u0026gt;GPF_MFPH \u0026amp; ~(SYS_GPF_MFPH_PF11MFP_Msk)) | (SYS_GPF_MFPH_PF11MFP_GPIO);\r/* Set PF.11 to GPIO intput */\rGPIO_SetMode(PF, BIT11, GPIO_MODE_INPUT);\rGPIO_EnableInt(PF, 11, GPIO_INT_FALLING);\rNVIC_EnableIRQ(GPF_IRQn);\r/* Set de-bounce function */\rGPIO_SET_DEBOUNCE_TIME(GPIO_DBCTL_DBCLKSRC_LIRC, GPIO_DBCTL_DBCLKSEL_512);\rGPIO_ENABLE_DEBOUNCE(PG, BIT15);\rGPIO_ENABLE_DEBOUNCE(PF, BIT11);\r}\rint main(void)\r{\ruint32_t sw1_cnt = 0, sw2_cnt = 0;\r/* Unlock protected registers */\rSYS_UnlockReg();\r/* Init System, peripheral clock and multi-function I/O */\rSYS_Init();\r/* Lock protected registers */\rSYS_LockReg();\r/* Init UART0 for printf */\rUART0_Init();\rprintf(\u0026#34;+---------------------------------------+\\n\u0026#34;);\rprintf(\u0026#34;| Level1 GPIO control Sample Code |\\n\u0026#34;);\rprintf(\u0026#34;+---------------------------------------+\\n\\n\u0026#34;);\r/* Init LED */\rLED_Init();\r/* Init BTN */\rBTN_Init();\rwhile(1) {\r/* Check if the SW1 is pressed */\rif (sw1_int_cnt != sw1_cnt) {\rsw1_cnt = sw1_int_cnt;\rprintf(\u0026#34;SW1 interrupt count: %d\\n\u0026#34;, sw1_cnt);\r}\r/* Check if the SW2 is pressed */\rif (sw2_int_cnt != sw2_cnt) {\rsw2_cnt = sw2_int_cnt;\rprintf(\u0026#34;SW2 interrupt count: %d\\n\u0026#34;, sw2_cnt);\r}\r}\r}\r//PG15\rvoid GPG_IRQHandler(void)\r{\rprintf(\u0026#34;+---------------------------------------+\\n\u0026#34;);\rprintf(\u0026#34;+------------Detect PG---------------+\\n\u0026#34;);\rprintf(\u0026#34;+---------------------------------------+\\n\u0026#34;);\r/* Check if PG.15 the interrupt occurred */\rif(GPIO_GET_INT_FLAG(PG, BIT15)) {\rLED_R ^= 1;\rsw1_int_cnt++;\r/* Clear PG.15 interrupt flag */\rGPIO_CLR_INT_FLAG(PG, BIT15);\r}else {\r/* Un-expected interrupt. Just clear all PB interrupts */\rPG-\u0026gt;INTSRC = PG-\u0026gt;INTSRC;\rprintf(\u0026#34;Un-expected interrupts.\\n\u0026#34;);\r}\r}\r//PF11\rvoid GPF_IRQHandler(void)\r{\rprintf(\u0026#34;+---------------------------------------+\\n\u0026#34;);\rprintf(\u0026#34;+------------Detect PF---------------+\\n\u0026#34;);\rprintf(\u0026#34;+---------------------------------------+\\n\u0026#34;);\r/* Check if PF.11 the interrupt occurred */\rif(GPIO_GET_INT_FLAG(PF, BIT11)) {\rLED_G ^= 1;\rsw2_int_cnt++;\r/* Clear PF.11 interrupt flag */\rGPIO_CLR_INT_FLAG(PF, BIT11);\r} else {\r/* Un-expected interrupt. Just clear all PB interrupts */\rPF-\u0026gt;INTSRC = PF-\u0026gt;INTSRC;\rprintf(\u0026#34;Un-expected interrupts.\\n\u0026#34;);\r}\r} M460 的控制LED範例 /*---------------------------------------------------------------------------------------------------------*/\r/* Main Function */\r/*---------------------------------------------------------------------------------------------------------*/\rint32_t main(void)\r{\r//Mode\r*(volatile unsigned int *)(0x400041C0) = 0x00001500;\r//value\r*(volatile unsigned int *)(0x400041C8) = 0x0000FF8F;\rwhile(1) {\rint i;\rfor(i = 0; i \u0026lt; 50000000; i++) {} //等1下\r*(volatile unsigned int *)(0x400041C8) = 0x00000000;\rfor(i = 0; i \u0026lt; 50000000; i++) {} //等1下\r*(volatile unsigned int *)(0x400041C8) = 0x00000070;\r}\r} *(volatile unsigned int *)(0x400041C0) = 0x00001500;\nRegister 位置\n0x40004000 + 0x1C0\nRegister的值\n0x 0000 1500\n000\u0026hellip;0 1500 如下圖\n*(volatile unsigned int *)(0x400041C8) = 0x00000070;\n0x1C8 是 PH_DOUT (port H out) 的控制\n70 如下圖所示 (0x00000070 全滅 0x00000000 全亮)\nint32_t main(void)\r{\r//Mode\r*(volatile unsigned int *)(0x400041C0) = 0x00001500;\rGPIO_SetMode(PH, BIT4, GPIO_MODE_OUTPUT);\r//value\r*(volatile unsigned int *)(0x400041C8) = 0x00000000;\rGPIO_SetMode(PH, BIT4, GPIO_MODE_OUTPUT);\rPH4 = 0;\rPH5 = 0;\rPH6 = 0;\rwhile(1) {\rint i;\rfor(i = 0; i \u0026lt; 50000000; i++) {} //等1百萬下\r// 全滅\r//*(volatile unsigned int *)(0x400041C8) = 0x00000000;\rPH4 = 1;\rPH5 = 1;\rPH6 = 1;\rfor(i = 0; i \u0026lt; 50000000; i++) {} //等1百萬下\r// 全亮\rPH4 = 0;\rPH5 = 0;\rPH6 = 0;\r}\r} M460 的控制Button範例 /**************************************************************************//**\r* @file main.c\r* @version V3.00\r* @brief Show the usage of GPIO interrupt function.\r*\r* @copyright SPDX-License-Identifier: Apache-2.0\r* @copyright Copyright (C) 2021 Nuvoton Technology Corp. All rights reserved.\r******************************************************************************/\r#include \u0026lt;stdio.h\u0026gt;\r#include \u0026#34;NuMicro.h\u0026#34;\rvoid GPH_IRQHandler(void);\rvoid SYS_Init(void);\rvoid UART0_Init(void);\r/**\r* @brief GPIO PH IRQ\r*\r* @param None\r*\r* @return None\r*\r* @details The PH default IRQ, declared in startup_m460.s.\r*/\rvoid GPH_IRQHandler(void)\r{\rvolatile uint32_t u32temp;\r/* To check if PH.0 interrupt occurred */\rif(GPIO_GET_INT_FLAG(PH, BIT0))\r{\rGPIO_CLR_INT_FLAG(PH, BIT0);\rprintf(\u0026#34;PH.0 INT occurred.\\n\u0026#34;);\r}\relse if(GPIO_GET_INT_FLAG(PH, BIT1))\r{\rGPIO_CLR_INT_FLAG(PH, BIT1);\rprintf(\u0026#34;PH.1 INT occurred.\\n\u0026#34;);\r}\relse\r{\r/* Un-expected interrupt. Just clear all PH interrupts */\ru32temp = PH-\u0026gt;INTSRC;\rPH-\u0026gt;INTSRC = u32temp;\rprintf(\u0026#34;Un-expected interrupts.\\n\u0026#34;);\r}\r}\rvoid SYS_Init(void)\r{\r/*---------------------------------------------------------------------------------------------------------*/\r/* Init System Clock */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Set PCLK0 and PCLK1 to HCLK/2 */\rCLK-\u0026gt;PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);\r/* Set core clock to 200MHz */\rCLK_SetCoreClock(200000000);\r/* Enable all GPIO clock */\rCLK-\u0026gt;AHBCLK0 |= CLK_AHBCLK0_GPACKEN_Msk | CLK_AHBCLK0_GPBCKEN_Msk | CLK_AHBCLK0_GPCCKEN_Msk | CLK_AHBCLK0_GPDCKEN_Msk |\rCLK_AHBCLK0_GPECKEN_Msk | CLK_AHBCLK0_GPFCKEN_Msk | CLK_AHBCLK0_GPGCKEN_Msk | CLK_AHBCLK0_GPHCKEN_Msk;\rCLK-\u0026gt;AHBCLK1 |= CLK_AHBCLK1_GPICKEN_Msk | CLK_AHBCLK1_GPJCKEN_Msk;\r/* Enable UART0 module clock */\rCLK_EnableModuleClock(UART0_MODULE);\r/* Select UART0 module clock source as HIRC and UART0 module clock divider as 1 */\rCLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HIRC, CLK_CLKDIV0_UART0(1));\r/*---------------------------------------------------------------------------------------------------------*/\r/* Init I/O Multi-function */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Set multi-function pins for UART0 RXD and TXD */\rSET_UART0_RXD_PB12();\rSET_UART0_TXD_PB13();\r}\rvoid UART0_Init(void)\r{\r/*---------------------------------------------------------------------------------------------------------*/\r/* Init UART */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Reset UART0 */\rSYS_ResetModule(UART0_RST);\r/* Configure UART0 and set UART0 baud rate */\rUART_Open(UART0, 115200);\r}\r/*---------------------------------------------------------------------------------------------------------*/\r/* Main Function */\r/*---------------------------------------------------------------------------------------------------------*/\rint32_t main(void)\r{\r/* Unlock protected registers */\rSYS_UnlockReg();\r/* Init System, peripheral clock and multi-function I/O */\rSYS_Init();\r/* Lock protected registers */\rSYS_LockReg();\r/* Init UART0 for printf */\rUART0_Init();\rprintf(\u0026#34;\\n\\nCPU @ %d Hz\\n\u0026#34;, SystemCoreClock);\rprintf(\u0026#34;+------------------------------------------------+\\n\u0026#34;);\rprintf(\u0026#34;| GPIO PH.0 and PH.1 Interrupt Sample Code |\\n\u0026#34;);\rprintf(\u0026#34;+------------------------------------------------+\\n\\n\u0026#34;);\r/*-----------------------------------------------------------------------------------------------------*/\r/* GPIO Interrupt Function Test */\r/*-----------------------------------------------------------------------------------------------------*/\rprintf(\u0026#34;PH.0 and PH.1 are used to test interrupt ......\\n\u0026#34;);\r/* Configure PH.0 as Input mode and enable interrupt by rising edge trigger */\rGPIO_SetMode(PH, BIT0, GPIO_MODE_INPUT);\rGPIO_EnableInt(PH, 0, GPIO_INT_RISING);\rNVIC_EnableIRQ(GPH_IRQn);\r/* Configure PH.1 as Quasi-bidirection mode and enable interrupt by falling edge trigger */\rGPIO_SetMode(PH, BIT1, GPIO_MODE_QUASI);\rGPIO_EnableInt(PH, 1, GPIO_INT_FALLING);\rNVIC_EnableIRQ(GPH_IRQn);\r/* Enable interrupt de-bounce function and select de-bounce sampling cycle time is 1024 clocks of LIRC clock */\rGPIO_SET_DEBOUNCE_TIME(PH, GPIO_DBCTL_DBCLKSRC_LIRC, GPIO_DBCTL_DBCLKSEL_1024);\rGPIO_SET_DEBOUNCE_TIME(PH, GPIO_DBCTL_DBCLKSRC_LIRC, GPIO_DBCTL_DBCLKSEL_1024);\rGPIO_ENABLE_DEBOUNCE(PH, BIT0);\rGPIO_ENABLE_DEBOUNCE(PH, BIT1);\r/* Waiting for interrupts */\rwhile(1);\r} ","permalink":"https://weizongchen.github.io/blog/gpio_introduce/","tags":["Cortex M4"],"title":"GPIO 說明"},{"categories":["安裝步驟文件"],"contents":"Description Enable the Remoteproc device driver in the Linux kernel.\n$ bitbake linux-ma35d1 -c menuconfig Device Drivers ---\u0026gt;\rRemoteproc drivers ---\u0026gt;\r[*] Support for Remote Processor subsystem\r\u0026lt;*\u0026gt; MA35D1 remoteproc support \u0026lt;Save\u0026gt; and \u0026lt;Exit\u0026gt; Description Modify the device tree node setting of remoteproc in the Linux kernel.\nLINUX_KERENL_PATH/arch/arm64/boot/dts/nuvoton/ma35d1.dtsi Description Compile the Linux kernel.\n$ bitbake linux-ma35d1 -C compile Description Modify the device tree node setting of SSPCC in the TF-A. 怎麼知道是I2S0_SUBM的?\nDescription Modify the device tree node setting of SSPCC in the TF-A. 怎麼知道是這4根pin角的?\nDescription Compile the TF-A.\n$ bitbake tf-a-ma35d1 -C compile Description Build-up Image. Qt 版本:\nbitbake nvt-image-qt5 -c cleanall \u0026amp;\u0026amp; bitbake nvt-image-qt5 Minimal 版本:\n$ bitbake core-image-minimal –c cleanall \u0026amp;\u0026amp; bitbake core-image-minimal Description Burn-in Image into SD card. 燒入SD卡\n$ sudo dd if=nvt-image-qt5-evb-ma35d1-xxxxx.rootfs.sdcard of=/dev/sdb 延展SD的size\rsudo ./ma35d1_resize.sh /dev/sdb 1 apply 把 M4 的.axf 放到SD卡的 /lib/firmware 中\nNote: The following step copy all of RTP (M4) sample codes in the M4_BSP into Filesystem. You can chose the sample code you want to use or replace with the firmware you developed. 執行 M4 axf 的指令\necho -n /lib/firmware \u0026gt; /sys/module/firmware_class/parameters/path\recho -n I2S_Codec_PDMA.elf \u0026gt; /sys/class/remoteproc/remoteproc0/firmware\recho start \u0026gt; /sys/class/remoteproc/remoteproc0/state\recho stop \u0026gt; /sys/class/remoteproc/remoteproc0/state Remoteproc - Keil IDE 設定\nNu-link 的DAP 要設定1\nPS:原本我們開發板的NuLink 是 0 ，MA35D1的要改1 ","permalink":"https://weizongchen.github.io/blog/ma35d1_rtp/","tags":["MA35D1","Cortex M4"],"title":"MA35D1 M4 使用設定"},{"categories":["安裝步驟文件"],"contents":"MA35D16A887C (BGA312) MCP package with DDR3L (256 MB)\n7-inch TFT LCD (1024x600) with touch daughter board\neMMC memory device daughter board\nSPI-NAND flash W25N02JWZEIF (256MB)\nNAND flash W29N01HVS1NA (128MB)\n2 x Giga Ethernet\n2 x High Speed USB\n2 x Camera Capture (CMOS sensor) header connectors\n1 x SIM Card slot\n2 x UART, 2 x RS485, 2 x CAN-FD, 8 x EADC channels\n基本安裝設定 Yocto 項目至少需要 150G 存儲\n在使用 Yocto 項目之前必須安裝必要的包\n$ sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib \\\rbuild-essential chrpath socat cpio python python3 python3-pip python3-pexpect \\\rxz-utils debianutils iputils-ping libsdl1.2-dev xterm curl Update existing list of packages\n$ sudo apt-get update Install a few prerequisite packages which let apt use packages over HTTPS\n$ sudo apt install apt-transport-https ca-certificates curl software-properties-common Add Docker’s official GPG key for the official Docker repository to your system\n$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add Set up the stable repository, add the Docker repository to APT sources\n$ sudo add-apt-repository \u0026#34;deb [arch=amd64] https://download.docker.com/linux/ubuntu focal stable\u0026#34; Update the package database with the Docker packages from the newly added repo\n$ sudo apt-get update Install Docker\n$ sudo apt-get install docker-ce docker-ce-cli containerd.io Download the Docker Script for MA35D1\n$ git clone https://github.com/OpenNuvoton/MA35D1_Docker_Script.git Enter docker-yocto folder, setup docker image, and select folder to be share\n$ ./build.sh It may take one hour to get 710 files.\rPlease enter absolute path for shared folders(eg:/home/\u0026lt;user name\u0026gt;) : Enter docker image, and your command line head will be like nuvoton@a24d9e06abe3:~$\n$ ./join.sh\rnua3500_nuvoton\rnuvoton@a24d9e06abe3:~$ Create a folder name yocto under /share\nnuvoton@a24d9e06abe3:~/share$ mkdir yocto The first time you use repo, you need to set up the GIT environment\nnuvoton@a24d9e06abe3:~/share/yocto$ git config --global user.email \u0026#34;test@test.test.test\u0026#34;\rnuvoton@a24d9e06abe3:~/share/yocto$ git config --global user.name \u0026#34;test\u0026#34;\rnuvoton@a24d9e06abe3:~/share/yocto$ git config --global http.sslverify false Go to /share/yocto to setup repo path\nnuvoton@a24d9e06abe3:~/share/yocto$ repo init -u https://github.com/OpenNuvoton/MA35D1_Yocto-v3.1.3.git -m meta-ma35d1/base/ma35d1.xml Download the yocto project\nnuvoton@a24d9e06abe3:~/share/yocto$ repo sync Build Image by Yocto Setup building configuration. The DISTRO option we usually use nvt-ma35d1-directfb\nEVB :\n~/yocto$ DISTRO=nvt-ma35d1-directfb MACHINE=ma35d1-evb source sources/init-build-env build SOM :\n~/yocto$ DISTRO=nvt-ma35d1-directfb MACHINE=numaker-som-ma35d16a81 source sources/init-build-env build MACHINE 目前有 SOM 板 或 IOT 板，後面ma35d16a81是 板號，所以客戶可以做他自己的板子，用自己得板號。\nMACHINE=numaker-som-ma35d16a81\nMACHINE=numaker-iot-ma35d16f70 ( f7 =\u0026gt; DDR 128MB )\nMACHINE=numaker-iot-ma35d16f90 ( f9 =\u0026gt; DDR 512MB )\ntest chip SOM :\n~/yocto$ DISTRO=nvt-ma35d1-directfb MACHINE=ma35d1-tc-som source sources/init-build-env build (補充說明) 假設我要改build 不同的板號，從numaker-som-ma35d16a81 改成 numaker-iot-ma35d16f70，有兩個地方要改 local.conf 的 Machine 要改如下 指定編譯 DISTRO=nvt-ma35d1-directfb MACHINE=numaker-iot-ma35d16f70 source sources/init-build-env build Choose what Image you want to build\nImage 包含Qt的版本 (建議)\nbitbake nvt-image-qt5 小 Image 版本\nbitbake core-image-minimal Copy the image to SD $ sudo dd if=nvt-image-qt5-evb-ma35d1-xxxxx.rootfs.sdcard of=/dev/sdb status=progress Fast Application Development Make a toolchain installer\n$ bitbake nvt-image-qt5 -c populate_sdk\r(This may take about 1 hour ) Go to the following path and execute the shell file\n~build/tmp-glibc/deploy/sdk $ ./oecore-x86_x64-aarch64-toolcahin-5.5-dunfell.sh Add toolchain to environment variables\n$ source /usr/local/oecore-x86_64/environment-setup-aarch64-poky-linux Create the source code file for this example: helloworld.c\n#include \u0026lt;stdio.h\u0026gt;\rint main() {\r// printf() displays the string inside console\rprintf(“Hello, World!\\n”);\rreturn 0;\r} Compile it\n$ $CC helloworld.c -o helloworld ","permalink":"https://weizongchen.github.io/blog/ma35d1_install_method/","tags":["MA35D1"],"title":"MA35D1 Yocto 安裝說明"},{"categories":["說明文件"],"contents":" 要找這個Register\n問這個PDBIASEN bit 找不到\u0026hellip;..\nCLK-\u0026gt;LDOCTL |= CLK_LDOCTL_PDBIASEN_Msk;\nClock, LDO control Rigister, PDBIASEN 這個 bit\nbit 18\n忘記在哪一版本TRM 有找到這個register\n右邊表格˙(1) (2) 沒有賣了，所以只是給過去參考，目前就是看(3) 就好~\nCore Coupled Memory Mode (CCM Mode)\nCCM Mode 是 SRAM 跟 SPI Flash 的關係，SPI Flash可以把SRAM當作catch來使用，\nCCMEN 打開 就是一般SRAM，不是catch\nWhen user sets CCMEN(SPIM_CTL1[2]) to 1, the operation mode of cache memory will be core coupled memory mode (CCM mode). In CCM mode, the cache function of SPI Flash controller is disabled by hardware automatically, and MCU can access this core coupled memory as general SRAM. When user sets CCMEN(SPIM_CTL1[2]) to 0 and MCU accesses CCM address range, SPI Flash controller will generate AHB error response to MCU.\n當用戶設置CCMEN(SPIM_CTL1[2])為1時，緩存存儲器操作模式會轉變成內核耦合存儲器模式(CCM模 式)。在CCM模式下，SPI flash控制器的緩存功能會被硬件自動禁用，MCU訪問內核耦合存儲器就像是 SRAM一樣。當用戶設置CCMEN(SPIM_CTL1[2])為0時MCU訪問CCM地址範圍，SPI flash控制器將會 產生AHB錯誤給MCU\n","permalink":"https://weizongchen.github.io/blog/question/","tags":null,"title":"自己的問題筆記"},{"categories":["安裝步驟文件"],"contents":"系統環境 Windows 10 VS 2019 OpenCV 4.5.5 選擇 Windows 版本的OpenCV download下來 解壓縮到指定資料夾 可以在C 根目錄建一個 OpenCV 資料夾，在OpenCV資料夾下再建一個OpenCV4.5.5資料夾，並解押到這裡面\n整理檔案位置，將需要的檔案拿出來就好 因為opencv資料夾的大小很大，可以刪除。如空間夠大可以留下來，以備不時之需。\nbin 資料夾說明 opencv 3 版本之後，只需要opencv_world455.dll就可以了，opencv_world455d.dll 多一個d是指 debug版本的意思。\n設定環境變數 建立一個空的C++專案 建立一個空的C++專案 在這裡應該有solution 和 project 的分別，我們要在solution的位置新增一個專案 建立屬性管理員 Property Manager 方便每次專案可以套用同一個屬性，比如哪天出了opencv新的版本，可以直接套用新的版本的opencv或使用更舊版本的opencv 去view打開屬姓管理員，預設是沒有顯示的。 使用x64的Release版本\n建一個有意義的名子，給x64、opencv版本是455、Release的版本使用的property 已產生此版本的屬性，待會就用這個屬性設定opencv的變數\n使用 Property Manager 設定OpenCV的環境 記得因為我們是使用 Release x64 版本的屬性所以上面要改一下\n基本上打到第2層，就會有提示字出現之後，就表示設定成功了，設定一下起始專案。\n寫一個簡單的程式測試一下 opencv 的設定 // loadimg.cpp : 此檔案包含 \u0026#39;main\u0026#39; 函式。程式會於該處開始執行及結束執行。\r//\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;opencv2/core/core.hpp\u0026gt;\r#include \u0026lt;opencv2/highgui/highgui.hpp\u0026gt;\rusing namespace std;\rusing namespace cv;\rint main()\r{\rMat img;\rimg = imread(\u0026#34;C:\\\\Users\\\\b51ak\\\\Pictures\\\\promotion.png\u0026#34;);\rnamedWindow(\u0026#34;figure 1\u0026#34;, WINDOW_AUTOSIZE);\rimshow(\u0026#34;figure 1\u0026#34;, img);\rstd::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\\n\u0026#34;;\rwaitKey(0);\rreturn 0;\r} ","permalink":"https://weizongchen.github.io/blog/opencv_env/","tags":["OpenCV"],"title":"OpenCV 環境安裝"}]