[{"categories":["說明文件"],"contents":"MA35D1 SPI Device Tree 路徑 : ~/yocto/build/tmp-glibc/work-shared/numaker-iot-ma35d16f90/kernel-source/arch/arm64/boot/dts/nuvoton/ma35d1.dtsi\nspi0: spi@40600000 {\rcompatible = \u0026#34;nuvoton,ma35d1-spi\u0026#34;;\rreg = \u0026lt;0x0 0x40600000 0x0 0x10000\u0026gt;;\rinterrupts = \u0026lt;GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH\u0026gt;;\rclocks = \u0026lt;\u0026amp;clk SPI0_GATE\u0026gt;;\rdmas = \u0026lt;\u0026amp;pdma1 4\u0026gt;,\u0026lt;\u0026amp;pdma1 5\u0026gt;;\rdma-names = \u0026#34;tx\u0026#34;,\u0026#34;rx\u0026#34;;\rpdma_reqsel_tx = \u0026lt;60\u0026gt;;\rpdma_reqsel_rx = \u0026lt;61\u0026gt;;\ruse_pdma = \u0026lt;0\u0026gt;;\rnum_cs = \u0026lt;2\u0026gt;;\rlsb = \u0026lt;0\u0026gt;;\rsleep = \u0026lt;0\u0026gt;;\rtxbitlen = \u0026lt;8\u0026gt;;\rbus_num = \u0026lt;2\u0026gt;;\rspimode = \u0026lt;0\u0026gt;;\rmrxphase = \u0026lt;0\u0026gt;;\rspi-max-frequency = \u0026lt;10000000\u0026gt;;\rstatus = \u0026#34;disabled\u0026#34;;\r}; 路徑 : ~/yocto/build/tmp-glibc/work-shared/numaker-iot-ma35d16f90/kernel-source/arch/arm64/boot/dts/nuvoton/ma35d1-iot-512m.dts\nCS = PG0\nCLK = PB9\nMOSI = PL14\nMISO =PL15\n使用PDMA 所以下面給1\n速度最高給12M (後面會蓋掉前面設定!)\n\u0026amp;spi0 {\rstatus = \u0026#34;okay\u0026#34;;\rpinctrl-names = \u0026#34;default\u0026#34;;\ruse_pdma = \u0026lt;1\u0026gt;;\rspi-max-frequency = \u0026lt;30000000\u0026gt;;\rpinctrl-0 = \u0026lt;\u0026amp;pinctrl_spi0\u0026gt;;\rspidev@0 {\rcompatible = \u0026#34;spidev\u0026#34;;\rreg = \u0026lt;0\u0026gt;;\rspi-max-frequency = \u0026lt;12000000\u0026gt;;\r};\r};\r\u0026amp;pinctrl {\rspi0 {\rpinctrl_spi0: spi0grp{\rnuvoton,pins =\r\u0026lt;SYS_GPG_MFPL_PG0MFP_SPI0_SS0 \u0026amp;pcfg_default\u0026gt;,\r\u0026lt;SYS_GPB_MFPH_PB8MFP_SPI0_SS1 \u0026amp;pcfg_default\u0026gt;,\r\u0026lt;SYS_GPB_MFPH_PB9MFP_SPI0_CLK \u0026amp;pcfg_default\u0026gt;,\r\u0026lt;SYS_GPL_MFPH_PL14MFP_SPI0_MOSI \u0026amp;pcfg_default\u0026gt;,\r\u0026lt;SYS_GPL_MFPH_PL15MFP_SPI0_MISO \u0026amp;pcfg_default\u0026gt;;\r};\r};\r}; 電路圖 Linux Driver: 路徑 : ~/yocto/build/tmp-glibc/work-shared/numaker-iot-ma35d16f90/kernel-source/drivers/spi\nstatic int nuvoton_spi_data_xfer(struct nuvoton_spi *hw, const void *txbuf,\rvoid *rxbuf, unsigned int len)\r{\r...\r} Linux Application: 環境上預設並沒有開啟spidev (decice node for user)須經由以下流程開啟: APP: 採用NUC980的 app https://github.com/OpenNuvoton/NUC980_Linux_Applications/blob/master/demos/spi/spidev_test.c\nAPP Makefile .SUFFIXES : .x .o .c .s\rSTRIP := aarch64-poky-linux-strip\r#TARGET = spidev_test\r#SRCS := spidev_test.c\rall:\r#\t$(CC) $(SRCS) -o $(TARGET) clean:\rrm -f *.o\rrm -f *.x\rrm -f *.flat\rrm -f *.map\rrm -f temp\rrm -f *.img\rrm -f $(TARGET)\rrm -f *.gdb Application 執行結果 ","permalink":"https://weizongchen.github.io/blog/ma35d1_spi/","tags":["MA35D1"],"title":"MA35D1 IoT 的 SPI 介面使用"},{"categories":["說明文件"],"contents":"跟新唐過去Cortex® M4 的 Feature 不一樣的地方 M4 speed 調升至 180 MHz 本章的重點，SRAM 有 128KB 以及 可以控制DDR 384KB Support Peripheral 1. UART、I2C、I2S、PDMA、SPI、etc… NuLink2Me Debug Wormhole Linux Setup Device Tree 查看各個 memory 設定 這裡是設定 Memory 的起始位置 8000 0000\n注意 Reserved-memory :\n在這裡，我們為不同的功能保留了三個塊。 其中一個地方是 rproc 函數，它用在 M4 DRAM 上(384KB)\n(0x60000 = 384 KB)\nDevice Tree 設定 以設定UART16 為例\n_S 就是代表指定給A35\n_SUBM 代表指定給M4\nCompile and make Image Compile the Linux kernel.\r$ bitbake linux-ma35d1 -C compile\rCompile the TF-A.\r$ bitbake tf-a-ma35d1 -C compile\rBuild-up Image.\r$ bitbake nvt-image-qt5 –c cleanall \u0026amp;\u0026amp; bitbake nvt-image-qt5\rBurn-in Image into SD card.\r$ sudo dd if=core-image-minimal-xxxxx.rootfs.sdcard of=/dev/sdbx 在 Keil IDE 設定 memory 使用空間 上圖中我們可以看到，RO data 配置位置在 0x0 ~ 0x1FFFF ，一共有128KB SRAM\nRW data 配置位置在 0x80040000 大小為0x1FFFF ，一共有128KB 的DDR\n我寫一個 c code 在 DDR memory 使用空間 在 .c 的右鍵 option ，可以指定要把這個 function 放到 DDR 去\n在 map file 中可以看到 memtest 已經在DDR 的 使用空間了\n使用 scatter file 去直接指定 哪個 上圖可以看到 紅色 是代表記憶體區間\n0x00000000 ~ 0x0001FFFF 是SRAM 的空間\n這裡的寫法可以直接打開 map file ，copy paste 一模一樣的名子就可以了，\n例如 : startup_ma35d1_rtp.o(STACK, HEAP) 這個我放到SRAM\npdm_converter.o(.bss) 我放到DRAM\n以此類推\n所以上圖可以知道，我把需要比較快速算完的data 放到SRAM\n比較不需要速度的資料我放到 DRAM\n","permalink":"https://weizongchen.github.io/blog/ma35d1_rtp_memory/","tags":["Cortex M4","MA35D1"],"title":"解決 MA35D1 M4 SRAM 128KB 不夠，調用A35 DDR space 384KB 的方法"},{"categories":["說明文件"],"contents":"PC 接好onboard的 nulink2 然後設定 Keil 的 option 這邊可以看到上圖我們開啟了412KB 的 flash 要使用\n在程式的部分，我open 一個 fmc\n寫一個pattern : 0x5A5A5A5A\n然後下面有兩個API可以參考(FMC_Write 、 FMC_Read)，其他可以去看新唐的fmc.c 參考。\n可以看到，我們用ICP查詢片上的flash 有0x5A5A5A5A 的資料被寫入\nFMC_Erase(u32Addr) 一次會Erase 4096 個 byte uTemp 一次要寫入 4 byte 的資料\nelse if( (i*4) == 4096)\n因為一次會寫入4 byte，所以當i=1024時，寫買了需要Erase新的4096 byte 空間\n","permalink":"https://weizongchen.github.io/blog/m4_fmc/","tags":["Cortex M4"],"title":"M4 把資料寫進 FMC的方法"},{"categories":["說明文件"],"contents":"\n原因是這裡可能空白 至少要選一個\n","permalink":"https://weizongchen.github.io/blog/error_flash_download_failed_cortex-m0/","tags":["Tool"],"title":"Error:Flash Download failed - Cortex-M0"},{"categories":["說明文件"],"contents":"開啟 Option Define 好 DEBUG_ENABLE_SEMIHOST 在 Debug Mode 的時候打開 UART #1 可以看到 UART0 的輸出 ","permalink":"https://weizongchen.github.io/blog/debug_enable_semihost/","tags":["Tool"],"title":"SemiHost 使用方法"},{"categories":["說明文件"],"contents":"找M460開發版的2根空的 I2C 由上圖可以知道 I2C Pin角選\nPA5 SCL 板上 PIN75\nPA4 SDA 板上 PIN76\nBSP 包 直接用 I2C_MultiBytes_Master /* Slave address */\ng_u8DeviceAddr = 0x46;\nBH1750的 ID 是 0x46 (包含第8個 bit)\nI2C_WriteByte(I2C0, device ID (不包含第8個bit), 要傳的命令)\nI2C_WriteByte(I2C0, 0x23, 0x10);\n這裡命令 0x10 是參考下圖\n//I2C_ReadByte(I2C0, device ID (不包含第8個bit));\n//r = I2C_ReadByte(I2C0, 0x23);\n讀到幾個byte = I2C_ReadMultiBytes(I2C0, device ID 不包含第8個bit, 放個陣列ReadData 會存到回到ReadData, 讀取長度len = 2 )\nreceive_byte = I2C_ReadMultiBytes(I2C0, 0x23, ReadData, 2);\nLA 量測結果 我MCU發送 0x46 (第8bit 值0 方向 write) ID ，並給值 0x10 給 Device\n0x46+1 (第8bit 值1 方向 read)Device 回 MCU 2個值 : 0x00 0xC5\n實體接線 /**************************************************************************//**\r* @file main.c\r* @version V3.00\r* @brief\r* Show how to set I2C use Multi bytes API Read and Write data to Slave.\r* Needs to work with I2C_Slave sample code.\r* @copyright (C) 2021 Nuvoton Technology Corp. All rights reserved.\r*****************************************************************************/\r#include \u0026lt;stdio.h\u0026gt;\r#include \u0026#34;NuMicro.h\u0026#34;\r#define PLL_CLOCK 192000000\r/*---------------------------------------------------------------------------------------------------------*/\r/* Global variables */\r/*---------------------------------------------------------------------------------------------------------*/\rvolatile uint8_t g_u8DeviceAddr;\rvolatile uint8_t g_au8MstTxData[3];\rvolatile uint8_t g_u8MstRxData;\rvolatile uint8_t g_u8MstDataLen;\rvolatile uint8_t g_u8MstEndFlag = 0;\rtypedef void (*I2C_FUNC)(uint32_t u32Status);\rvolatile static I2C_FUNC s_I2C0HandlerFn = NULL;\rvoid SYS_Init(void)\r{\r/*---------------------------------------------------------------------------------------------------------*/\r/* Init System Clock */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Set PCLK0 and PCLK1 to HCLK/2 */\rCLK-\u0026gt;PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);\r/* Set core clock to 200MHz */\rCLK_SetCoreClock(200000000);\r/* Enable all GPIO clock */\rCLK-\u0026gt;AHBCLK0 |= CLK_AHBCLK0_GPACKEN_Msk | CLK_AHBCLK0_GPBCKEN_Msk | CLK_AHBCLK0_GPCCKEN_Msk | CLK_AHBCLK0_GPDCKEN_Msk |\rCLK_AHBCLK0_GPECKEN_Msk | CLK_AHBCLK0_GPFCKEN_Msk | CLK_AHBCLK0_GPGCKEN_Msk | CLK_AHBCLK0_GPHCKEN_Msk;\rCLK-\u0026gt;AHBCLK1 |= CLK_AHBCLK1_GPICKEN_Msk | CLK_AHBCLK1_GPJCKEN_Msk;\r/* Enable UART0 module clock */\rCLK_EnableModuleClock(UART0_MODULE);\r/* Select UART0 module clock source as HIRC and UART0 module clock divider as 1 */\rCLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HIRC, CLK_CLKDIV0_UART0(1));\r/* Enable I2C0 peripheral clock */\rCLK_EnableModuleClock(I2C0_MODULE);\r/*---------------------------------------------------------------------------------------------------------*/\r/* Init I/O Multi-function */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Set multi-function pins for UART0 RXD and TXD */\rSET_UART0_RXD_PB12();\rSET_UART0_TXD_PB13();;\r/* Set I2C0 multi-function pins */\rSET_I2C0_SDA_PA4();\rSET_I2C0_SCL_PA5();\r/* I2C pin enable schmitt trigger */\rPA-\u0026gt;SMTEN |= GPIO_SMTEN_SMTEN4_Msk | GPIO_SMTEN_SMTEN5_Msk;\r}\rvoid I2C0_Init(void)\r{\r/* Open I2C module and set bus clock */\rI2C_Open(I2C0, 100000);\r/* Get I2C0 Bus Clock */\rprintf(\u0026#34;I2C clock %d Hz\\n\u0026#34;, I2C_GetBusClockFreq(I2C0));\r}\rvoid I2C0_Close(void)\r{\r/* Disable I2C0 interrupt and clear corresponding NVIC bit */\rI2C_DisableInt(I2C0);\rNVIC_DisableIRQ(I2C0_IRQn);\r/* Disable I2C0 and close I2C0 clock */\rI2C_Close(I2C0);\rCLK_DisableModuleClock(I2C0_MODULE);\r}\rint32_t main(void)\r{\ruint32_t receive_byte;\ruint8_t ReadData[2];\ruint32_t Lux;\ruint32_t i;\ruint8_t txbuf[256] = {0}, rDataBuf[256] = {0};\r/* Unlock protected registers */\rSYS_UnlockReg();\r/* Init System, IP clock and multi-function I/O. */\rSYS_Init();\r/* Configure UART0: 115200, 8-bit word, no parity bit, 1 stop bit. */\rUART_Open(UART0, 115200);\r#ifdef _PZ\r/* For palladium */\rUART0-\u0026gt;BAUD = UART_BAUD_MODE2 | UART_BAUD_MODE2_DIVIDER(153600, 38400);\r#endif\r/*\rThis sample code sets I2C bus clock to 100kHz. Then, Master accesses Slave with Multi Bytes Write\rand Multi Bytes Read operations, and check if the read data is equal to the programmed data.\r*/\rprintf(\u0026#34;+--------------------------------------------------------+\\n\u0026#34;);\rprintf(\u0026#34;| I2C Driver Sample Code for Multi Bytes Read/Write Test |\\n\u0026#34;);\rprintf(\u0026#34;| Needs to work with I2C_Slave sample code |\\n\u0026#34;);\rprintf(\u0026#34;| |\\n\u0026#34;);\rprintf(\u0026#34;| I2C Master (I2C0) \u0026lt;---\u0026gt; I2C Slave(I2C0) |\\n\u0026#34;);\rprintf(\u0026#34;| !! This sample code requires two borads to test !! |\\n\u0026#34;);\rprintf(\u0026#34;+--------------------------------------------------------+\\n\u0026#34;);\rprintf(\u0026#34;\\n\u0026#34;);\r/* Init I2C0 */\rI2C0_Init();\r/* Slave address */\rg_u8DeviceAddr = 0x46;\rI2C_WriteByte(I2C0, 0x23, 0x10);\r//r = I2C_ReadByte(I2C0, 0x23);\rreceive_byte = I2C_ReadMultiBytes(I2C0, 0x23, ReadData, 2);\rprintf(\u0026#34;receive_byte = %d \\n\u0026#34;, receive_byte);\rprintf(\u0026#34;ReadData[0] = %x \\n\u0026#34;, ReadData[0]);\rprintf(\u0026#34;ReadData[1] = %x \\n\u0026#34;, ReadData[1]);\rLux = ReadData[0] * 256 + ReadData[1];\rwhile(1)\r{\rI2C_ReadMultiBytes(I2C0, 0x23, ReadData, 2);\rLux = ReadData[0] * 256 + ReadData[1];\rprintf(\u0026#34;Lux = %d \\n\u0026#34;, Lux);\r}\r}\r/*** (C) COPYRIGHT 2021 Nuvoton Technology Corp. ***/ ","permalink":"https://weizongchen.github.io/blog/i2c_bh1750/","tags":["Cortex M4"],"title":"使用M460開發版的 I2C 去要 BH1750 照度計sensor的data"},{"categories":["說明文件"],"contents":"BSP EPWM 我是找 BSP 使用的 PWM PIN 角， 但還是用pinconfigure 看一下\n所以根據上圖以及BSP ，\nPWM1 的 Channel0\n會發訊號 給\nPWM1 的 Channel2\n查看開發版的電路圖 是哪兩根PIN EPWM_Capture BSP 的 console 量測邏輯分析儀 EPWM1 的 channel0 發 250 Hz pwm 訊號 30% duty\n/**************************************************************************//**\r* @file main.c\r* @version V3.00\r* @brief Capture the EPWM1 Channel 0 waveform by EPWM1 Channel 2.\r*\r* @copyright SPDX-License-Identifier: Apache-2.0\r* @copyright Copyright (C) 2021 Nuvoton Technology Corp. All rights reserved.\r******************************************************************************/\r#include \u0026lt;stdio.h\u0026gt;\r#include \u0026#34;NuMicro.h\u0026#34;\r/*---------------------------------------------------------------------------------------------------------*/\r/* Macro, type and constant definitions */\r/*---------------------------------------------------------------------------------------------------------*/\r/*---------------------------------------------------------------------------------------------------------*/\r/* Global variables */\r/*---------------------------------------------------------------------------------------------------------*/\rvoid CalPeriodTime(EPWM_T *EPWM, uint32_t u32Ch);\rvoid SYS_Init(void);\rvoid UART0_Init(void);\r/*--------------------------------------------------------------------------------------*/\r/* Capture function to calculate the input waveform information */\r/* au32Count[4] : Keep the internal counter value when input signal rising / falling */\r/* happens */\r/* */\r/* time A B C D */\r/* ___ ___ ___ ___ ___ ___ ___ ___ */\r/* ____| |_| |_| |_| |_| |_| |_| |_| |_____ */\r/* index 0 1 2 3 */\r/* */\r/* The capture internal counter down count from 0x10000, and reload to 0x10000 after */\r/* input signal falling happens (Time B/C/D) */\r/*--------------------------------------------------------------------------------------*/\rvoid CalPeriodTime(EPWM_T *EPWM, uint32_t u32Ch)\r{\ruint16_t au16Count[4];\ruint32_t u32i;\ruint16_t u16RisingTime, u16FallingTime, u16HighPeriod, u16LowPeriod, u16TotalPeriod;\r/* Clear Capture Falling Indicator (Time A) */\rEPWM_ClearCaptureIntFlag(EPWM, u32Ch, EPWM_CAPTURE_INT_FALLING_LATCH);\r/* Wait for Capture Falling Indicator */\rwhile((EPWM1-\u0026gt;CAPIF \u0026amp; EPWM_CAPIF_CFLIF2_Msk) == 0);\r/* Clear Capture Falling Indicator (Time B)*/\rEPWM_ClearCaptureIntFlag(EPWM, u32Ch, EPWM_CAPTURE_INT_FALLING_LATCH);\ru32i = 0;\rwhile(u32i \u0026lt; 4)\r{\r/* Wait for Capture Falling Indicator */\rwhile(EPWM_GetCaptureIntFlag(EPWM, u32Ch) \u0026lt; 2);\r/* Clear Capture Falling and Rising Indicator */\rEPWM_ClearCaptureIntFlag(EPWM, u32Ch, EPWM_CAPTURE_INT_FALLING_LATCH | EPWM_CAPTURE_INT_RISING_LATCH);\r/* Get Capture Falling Latch Counter Data */\rau16Count[u32i++] = (uint16_t)EPWM_GET_CAPTURE_FALLING_DATA(EPWM, u32Ch);\r/* Wait for Capture Rising Indicator */\rwhile(EPWM_GetCaptureIntFlag(EPWM, u32Ch) \u0026lt; 2);\r/* Clear Capture Rising Indicator */\rEPWM_ClearCaptureIntFlag(EPWM, u32Ch, EPWM_CAPTURE_INT_RISING_LATCH);\r/* Get Capture Rising Latch Counter Data */\rau16Count[u32i++] = (uint16_t)EPWM_GET_CAPTURE_RISING_DATA(EPWM, u32Ch);\r}\ru16RisingTime = au16Count[1];\ru16FallingTime = au16Count[0];\ru16HighPeriod = au16Count[1] - au16Count[2];\ru16LowPeriod = (uint16_t)(0x10000 - au16Count[1]);\ru16TotalPeriod = (uint16_t)(0x10000 - au16Count[2]);\rprintf(\u0026#34;\\nEPWM generate: \\nHigh Period=17141 ~ 17143, Low Period=39999 ~ 40001, Total Period=57141 ~ 57143\\n\u0026#34;);\rprintf(\u0026#34;\\nCapture Result: Rising Time = %d, Falling Time = %d \\nHigh Period = %d, Low Period = %d, Total Period = %d.\\n\\n\u0026#34;,\ru16RisingTime, u16FallingTime, u16HighPeriod, u16LowPeriod, u16TotalPeriod);\rif((u16HighPeriod \u0026lt; 17141) || (u16HighPeriod \u0026gt; 17143) || (u16LowPeriod \u0026lt; 39999) || (u16LowPeriod \u0026gt; 40001) || (u16TotalPeriod \u0026lt; 57141) || (u16TotalPeriod \u0026gt; 57143))\rprintf(\u0026#34;Capture Test Fail!!\\n\u0026#34;);\relse\rprintf(\u0026#34;Capture Test Pass!!\\n\u0026#34;);\r}\rvoid SYS_Init(void)\r{\r/* Set PF multi-function pins for XT1_OUT(PF.2) and XT1_IN(PF.3) */\rSET_XT1_OUT_PF2();\rSET_XT1_IN_PF3();\r/*---------------------------------------------------------------------------------------------------------*/\r/* Init System Clock */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Enable HIRC and HXT clock */\rCLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk | CLK_PWRCTL_HXTEN_Msk);\r/* Wait for HIRC and HXT clock ready */\rCLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk | CLK_STATUS_HXTSTB_Msk);\r/* Set PCLK0 and PCLK1 to HCLK/2 */\rCLK-\u0026gt;PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);\r/* Set core clock to 200MHz */\rCLK_SetCoreClock(200000000);\r/* Enable all GPIO clock */\rCLK-\u0026gt;AHBCLK0 |= CLK_AHBCLK0_GPACKEN_Msk | CLK_AHBCLK0_GPBCKEN_Msk | CLK_AHBCLK0_GPCCKEN_Msk | CLK_AHBCLK0_GPDCKEN_Msk |\rCLK_AHBCLK0_GPECKEN_Msk | CLK_AHBCLK0_GPFCKEN_Msk | CLK_AHBCLK0_GPGCKEN_Msk | CLK_AHBCLK0_GPHCKEN_Msk;\rCLK-\u0026gt;AHBCLK1 |= CLK_AHBCLK1_GPICKEN_Msk | CLK_AHBCLK1_GPJCKEN_Msk;\r/* Enable UART0 module clock */\rCLK_EnableModuleClock(UART0_MODULE);\r/* Select UART0 module clock source as HIRC and UART0 module clock divider as 1 */\rCLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HIRC, CLK_CLKDIV0_UART0(1));\r/* Enable EPWM1 module clock */\rCLK_EnableModuleClock(EPWM1_MODULE);\r/* Select EPWM1 module clock source */\rCLK_SetModuleClock(EPWM1_MODULE, CLK_CLKSEL2_EPWM1SEL_PCLK1, 0);\r/*---------------------------------------------------------------------------------------------------------*/\r/* Init I/O Multi-function */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Set multi-function pins for UART0 RXD and TXD */\rSET_UART0_RXD_PB12();\rSET_UART0_TXD_PB13();\r/* Set multi-function pin for EPWM */\rSET_EPWM1_CH0_PC5();\rSET_EPWM1_CH2_PC3();\r}\rvoid UART0_Init(void)\r{\r/*---------------------------------------------------------------------------------------------------------*/\r/* Init UART */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Configure UART0 and set UART0 baud rate */\rUART_Open(UART0, 115200);\r}\r/*---------------------------------------------------------------------------------------------------------*/\r/* Main Function */\r/*---------------------------------------------------------------------------------------------------------*/\rint32_t main(void)\r{\r/* Init System, IP clock and multi-function I/O\rIn the end of SYS_Init() will issue SYS_LockReg()\rto lock protected register. If user want to write\rprotected register, please issue SYS_UnlockReg()\rto unlock protected register if necessary */\r/* Unlock protected registers */\rSYS_UnlockReg();\r/* Init System, IP clock and multi-function I/O */\rSYS_Init();\r/* Lock protected registers */\rSYS_LockReg();\r/* Init UART to 115200-8n1 for print message */\rUART0_Init();\rprintf(\u0026#34;\\n\\nCPU @ %dHz(PLL@ %dHz)\\n\u0026#34;, SystemCoreClock, PllClock);\rprintf(\u0026#34;+------------------------------------------------------------------------+\\n\u0026#34;);\rprintf(\u0026#34;| EPWM Driver Sample Code |\\n\u0026#34;);\rprintf(\u0026#34;| |\\n\u0026#34;);\rprintf(\u0026#34;+------------------------------------------------------------------------+\\n\u0026#34;);\rprintf(\u0026#34; This sample code will use EPWM1 channel 2 to capture\\n the signal from EPWM1 channel 0.\\n\u0026#34;);\rprintf(\u0026#34; I/O configuration:\\n\u0026#34;);\rprintf(\u0026#34; EPWM1 channel 2(PC.3) \u0026lt;--\u0026gt; EPWM1 channel 0(PC.5)\\n\\n\u0026#34;);\rprintf(\u0026#34;Use EPWM1 Channel 2(PC.3) to capture the EPWM1 Channel 0(PC.5) Waveform\\n\u0026#34;);\rwhile(1)\r{\rprintf(\u0026#34;\\n\\nPress any key to start EPWM Capture Test\\n\u0026#34;);\rgetchar();\r/*--------------------------------------------------------------------------------------*/\r/* Set the EPWM1 Channel 0 as EPWM output function. */\r/*--------------------------------------------------------------------------------------*/\r/* Assume EPWM output frequency is 250Hz and duty ratio is 30%, user can calculate EPWM settings by follows.(up counter type)\rduty ratio = (CMR)/(CNR+1)\rcycle time = CNR+1\rHigh level = CMR\rEPWM clock source frequency = PLL/2 = 100000000\r(CNR+1) = EPWM clock source frequency/prescaler/EPWM output frequency\r= 100000000/7/250 = 57142\r(Note: CNR is 16 bits, so if calculated value is larger than 65536, user should increase prescale value.)\rCNR = 57141\rduty ratio = 30% ==\u0026gt; (CMR)/(CNR+1) = 30%\rCMR = 17142\rPrescale value is 6 : prescaler= 7\r*/\r/* Set EPWM1 channel 0 output configuration */\rEPWM_ConfigOutputChannel(EPWM1, 0, 250, 30);\r/* Enable EPWM Output path for EPWM1 channel 0 */\rEPWM_EnableOutput(EPWM1, EPWM_CH_0_MASK);\r/* Enable Timer for EPWM1 channel 0 */\rEPWM_Start(EPWM1, EPWM_CH_0_MASK);\r/*--------------------------------------------------------------------------------------*/\r/* Set the EPWM1 channel 2 for capture function */\r/*--------------------------------------------------------------------------------------*/\r/* If input minimum frequency is 250Hz, user can calculate capture settings by follows.\rCapture clock source frequency = PLL = 100000000 in the sample code.\r(CNR+1) = Capture clock source frequency/prescaler/minimum input frequency\r= 100000000/7/250 = 57142\r(Note: CNR is 16 bits, so if calculated value is larger than 65536, user should increase prescale value.)\rCNR = 0xFFFF\r(Note: In capture mode, user should set CNR to 0xFFFF to increase capture frequency range.)\rCapture unit time = 1/Capture clock source frequency/prescaler\r70 ns = 1/100000000/7\r*/\r/* Set EPWM1 channel 2 capture configuration */\rEPWM_ConfigCaptureChannel(EPWM1, 2, 70, 0);\r/* Enable Timer for EPWM1 channel 2 */\rEPWM_Start(EPWM1, EPWM_CH_2_MASK);\r/* Enable Capture Function for EPWM1 channel 2 */\rEPWM_EnableCapture(EPWM1, EPWM_CH_2_MASK);\r/* Enable falling capture reload */\rEPWM1-\u0026gt;CAPCTL |= EPWM_CAPCTL_FCRLDEN2_Msk;\r/* Wait until EPWM1 channel 2 Timer start to count */\rwhile((EPWM1-\u0026gt;CNT[2]) == 0);\r/* Capture the Input Waveform Data */\rCalPeriodTime(EPWM1, 2);\r/*------------------------------------------------------------------------------------------------------------*/\r/* Stop EPWM1 channel 0 (Recommended procedure method 1) */\r/* Set EPWM Timer loaded value(Period) as 0. When EPWM internal counter(CNT) reaches to 0, disable EPWM Timer */\r/*------------------------------------------------------------------------------------------------------------*/\r/* Set EPWM1 channel 0 loaded value as 0 */\rEPWM_Stop(EPWM1, EPWM_CH_0_MASK);\r/* Wait until EPWM1 channel 0 Timer Stop */\rwhile((EPWM1-\u0026gt;CNT[0] \u0026amp; EPWM_CNT0_CNT_Msk) != 0);\r/* Disable Timer for EPWM1 channel 0 */\rEPWM_ForceStop(EPWM1, EPWM_CH_0_MASK);\r/* Disable EPWM Output path for EPWM1 channel 0 */\rEPWM_DisableOutput(EPWM1, EPWM_CH_0_MASK);\r/*------------------------------------------------------------------------------------------------------------*/\r/* Stop EPWM1 channel 2 (Recommended procedure method 1) */\r/* Set EPWM Timer loaded value(Period) as 0. When EPWM internal counter(CNT) reaches to 0, disable EPWM Timer */\r/*------------------------------------------------------------------------------------------------------------*/\r/* Set loaded value as 0 for EPWM1 channel 2 */\rEPWM_Stop(EPWM1, EPWM_CH_2_MASK);\r/* Wait until EPWM1 channel 2 current counter reach to 0 */\rwhile((EPWM1-\u0026gt;CNT[2] \u0026amp; EPWM_CNT2_CNT_Msk) != 0);\r/* Disable Timer for EPWM1 channel 2 */\rEPWM_ForceStop(EPWM1, EPWM_CH_2_MASK);\r/* Disable Capture Function and Capture Input path for EPWM1 channel 2*/\rEPWM_DisableCapture(EPWM1, EPWM_CH_2_MASK);\r/* Clear Capture Interrupt flag for EPWM1 channel 2 */\rEPWM_ClearCaptureIntFlag(EPWM1, 2, EPWM_CAPTURE_INT_FALLING_LATCH);\r}\r}\r/*** (C) COPYRIGHT 2021 Nuvoton Technology Corp. ***/ ","permalink":"https://weizongchen.github.io/blog/pwm/","tags":["Cortex M4"],"title":" PWM 的 應用範例 "},{"categories":["說明文件"],"contents":"Timer0 電路位置 由pinconfigure 可以知道Timer0 在 pin 1 (PB5) 接著\n設定 Timer0 pin 角 //\u0026mdash;PIN\u0026mdash;- /* Set timer toggle out pin */ SET_TM0_PB5();\nTimer Delay Delay 1 秒:\nTIMER_Delay(TIMER0, 1000000);\nTimer init_TIMER0_Toggle TIMER_Open(TIMER0, TIMER_TOGGLE_MODE, 250000);\n開啟TIMER0 反轉250K\n邏輯分析儀量測 邏輯分析儀 桶著 Pin1 開 Salease 邏輯分析儀 SW 可以發現訊號是125K Hz 波峰 +波谷 就250K Hz\n/*---------------------------------------------------------------------------------------------------------*/\r/* Global Interface Variables Declarations */\r/*---------------------------------------------------------------------------------------------------------*/\rvolatile uint32_t g_au32TMRINTCount[4] = {0};\r//----------------- TIMER0 --------------------\rvoid TMR0_IRQHandler(void)\r{\rif(TIMER_GetIntFlag(TIMER0) == 1)\r{\r/* Clear Timer0 time-out interrupt flag */\rTIMER_ClearIntFlag(TIMER0);\rg_au32TMRINTCount[0]++;\rPH4 ^= 1;\r}\r}\rvoid TMR0_Init(void)\r{\r/* Enable TIMER module clock */\r//---clock---\rCLK_EnableModuleClock(TMR0_MODULE);\rCLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_HXT, 0);\r//---PIN----\r/* Set timer toggle out pin */\rSET_TM0_PB5();\r/* Open Timer0 in periodic mode, enable interrupt and 1 interrupt tick per second */\rTIMER_Open(TIMER0, TIMER_PERIODIC_MODE, 1);\r/* Start Timer0 ~ Timer3 counting */\rTIMER_Start(TIMER0);\r//--- NVIC ----\rTIMER_EnableInt(TIMER0);\r/* Enable Timer0 ~ Timer3 NVIC */\rNVIC_EnableIRQ(TMR0_IRQn);\r/* Check Timer0 ~ Timer3 interrupt counts */\r//g_au32TMRINTCount[0];\r}\rvoid init_TIMER0_Toggle(void)\r{\r/* Enable TIMER module clock */\r//---clock---\rCLK_EnableModuleClock(TMR0_MODULE);\rCLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_HXT, 0);\r//---PIN----\r/* Set timer toggle out pin */\rSET_TM0_PB5();\r/* Open Timer0 in periodic mode, enable interrupt and 1 interrupt tick per second */\rTIMER_Open(TIMER0, TIMER_TOGGLE_MODE, 250000);\r/* Start Timer0 ~ Timer3 counting */\rTIMER_Start(TIMER0);\r}\r//-------------- HCLK -------------\rvoid init_HCLK(void){\rSYS_UnlockReg();\r/*---------------------------------------------------------------------------------------------------------*/\r/* Init System Clock */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Set PCLK0 and PCLK1 to HCLK/2 */\rCLK-\u0026gt;PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);\r/* Set core clock to 200MHz */\rCLK_SetCoreClock(200000000);\r/* Enable all GPIO clock */\rCLK-\u0026gt;AHBCLK0 |= CLK_AHBCLK0_GPACKEN_Msk | CLK_AHBCLK0_GPBCKEN_Msk | CLK_AHBCLK0_GPCCKEN_Msk | CLK_AHBCLK0_GPDCKEN_Msk |\rCLK_AHBCLK0_GPECKEN_Msk | CLK_AHBCLK0_GPFCKEN_Msk | CLK_AHBCLK0_GPGCKEN_Msk | CLK_AHBCLK0_GPHCKEN_Msk;\rCLK-\u0026gt;AHBCLK1 |= CLK_AHBCLK1_GPICKEN_Msk | CLK_AHBCLK1_GPJCKEN_Msk;\r/* Enable HXT clock */\rCLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);\rCLK_WaitClockReady( CLK_STATUS_HXTSTB_Msk);\rSYS_LockReg();\r}\r/*---------------------------------------------------------------------------------------------------------*/\r/* Main Function */\r/*---------------------------------------------------------------------------------------------------------*/\rint32_t main(void)\r{\ruint16_t cnt = 0;\ruint8_t STA = 0;\r/* Unlock protected registers */\rSYS_UnlockReg();\r/* Init System, peripheral clock and multi-function I/O */\rSYS_Init();\r/* Lock protected registers */\rSYS_LockReg();\r/* Init UART0 for printf */\rUART0_Init();\rinit_HCLK();\rinit_TIMER0_Toggle();\r// PH4 LED R\rGPIO_SetMode(PH, BIT4, GPIO_MODE_OUTPUT);\rwhile(1) {\r}\r} ","permalink":"https://weizongchen.github.io/blog/timer_init_timer0_toggle/","tags":["Cortex M4"],"title":"Timer Toggle 使用邏輯分析儀量測timer toggle (by M460)"},{"categories":["說明文件"],"contents":" 新唐 Pinconfigure 地址 https://www.nuvoton.com/resource-download.jsp?tp_GUID=SW1320200319135912\n當發現我要的IC 沒有出現在 我要的M460 沒有在 Pinconfigure 選單\nDownload 新的exe file Pinconfigure 下載\nM460 出現了 ","permalink":"https://weizongchen.github.io/blog/install_and_update_pinconfigure/","tags":["Tool"],"title":"安裝新唐 Pinconfigure "},{"categories":["說明文件"],"contents":"Button 的 狀態討論 /*---------------------------------------------------------------------------------------------------------*/\r/* Main Function */\r/*---------------------------------------------------------------------------------------------------------*/\rint32_t main(void)\r{\ruint16_t cnt = 0;\ruint8_t STA = 0;\r/* Unlock protected registers */\rSYS_UnlockReg();\r/* Init System, peripheral clock and multi-function I/O */\rSYS_Init();\r/* Lock protected registers */\rSYS_LockReg();\r/* Init UART0 for printf */\rUART0_Init();\rwhile(1) {\rSTA \u0026lt;\u0026lt;= 1;\rSTA += PH0;\rprintf(\u0026#34;%d \\n\u0026#34;, PH0);\rTIMER_Delay(TIMER0, 1000000);\rSTA \u0026amp;= 3;\rif(STA == 2) {\rcnt++;\r//printf(\u0026#34;%d \u0026#34;, cnt);\r}\r//TIMER_Delay(TIMER0, 1000000);\r}\r} STA 原始值 00000000(0)\n二進制 (十進制)\rSTA :\n第一圈 結果 00000000 左移一次 00000000 00000000+ PH0(1) [沒有按] 00000001 00000001 \u0026amp; 00000011(3) 00000001(1) STA == 2 false 第二圈 結果 00000001 左移一次 00000010 00000010 + PH0(1) [沒有按] 00000011 00000011 \u0026amp; 00000011(3) 00000011(3) STA == 2 false 第三圈 結果 00000011 左移一次 00000110 00000110 + PH0(1) [沒有按] 00000111 00000111 \u0026amp; 00000011(3) 00000011(3) STA == 2 false 第四圈 結果 00000011 左移一次 00000110 00000110 + PH0(1) [沒有按] 00000111 00000111 \u0026amp; 00000011(3) 00000011(3) STA == 2 false 第五圈 結果 00000011 左移一次 00000110 00000110 + PH0(0) [按下去] 00000110 00000110 \u0026amp; 00000011(3) 00000010(2) STA == 2 true 印數字 (CPU執行很快，可能不小心print到數個數字)\n第六圈 結果 00000010 左移一次 00000100 00000100 + PH0(0) [還按著] 00000100 00000100 \u0026amp; 00000011(3) 00000000(0) STA == 2 false 第七圈 結果 00000000 左移一次 00000000 00000000 + PH0(0) [還按著] 00000000 00000000 \u0026amp; 00000011(3) 00000000(0) STA == 2 false 第八圈 (等於第一圈) 結果 00000000 左移一次 00000000 00000000 + PH0(1) [沒有按] 00000001 00000001 \u0026amp; 00000011(3) 00000001(1) STA == 2 false ","permalink":"https://weizongchen.github.io/blog/btn/","tags":["Cortex M4"],"title":"Button 的各種說明"},{"categories":["說明文件"],"contents":"加入Timer的Driver 在 SYS_Init() 時 ，加入TMR0 的 clock source /*---------------------------------------------------------------------------------------------------------*/\r/* Initialization for sample code */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Enable TIMER module clock */\rCLK_EnableModuleClock(TMR0_MODULE);\r/* Select TIMER clock source */\rCLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_HIRC, 0); 在 SYS_Init() 時 ，加入TMR0 的 clock source while(1) {\rPH4 = 1;\rTIMER_Delay(TIMER0, 1000000);\rPH4 = 0;\rTIMER_Delay(TIMER0, 1000000);\r} 邏輯分析儀量測 LED 訊號 用 Timer0 控制 LED 1秒亮 1秒滅 /**************************************************************************//**\r* @file main.c\r* @version V3.00\r* @brief Transmit and receive data from PC terminal through RS232 interface.\r*\r* @copyright SPDX-License-Identifier: Apache-2.0\r* @copyright Copyright (C) 2021 Nuvoton Technology Corp. All rights reserved.\r******************************************************************************/\r#include \u0026lt;stdio.h\u0026gt;\r#include \u0026#34;NuMicro.h\u0026#34;\r#define RXBUFSIZE 1024\r/*---------------------------------------------------------------------------------------------------------*/\r/* Global variables */\r/*---------------------------------------------------------------------------------------------------------*/\rstatic uint8_t g_u8RecData[RXBUFSIZE] = {0};\rstatic volatile uint32_t g_u32comRbytes = 0;\rstatic volatile uint32_t g_u32comRhead = 0;\rstatic volatile uint32_t g_u32comRtail = 0;\rstatic volatile int32_t g_i32Wait = TRUE;\r/*---------------------------------------------------------------------------------------------------------*/\r/* Define functions prototype */\r/*---------------------------------------------------------------------------------------------------------*/\rint32_t main(void);\rvoid UART_TEST_HANDLE(void);\rvoid UART_FunctionTest(void);\rvoid SYS_Init(void);\rvoid UART0_Init(void);\rvoid UART0_IRQHandler(void);\rvoid SYS_Init(void)\r{\r/*---------------------------------------------------------------------------------------------------------*/\r/* Init System Clock */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Set PCLK0 and PCLK1 to HCLK/2 */\rCLK-\u0026gt;PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);\r/* Set core clock to 200MHz */\rCLK_SetCoreClock(200000000);\r/* Enable all GPIO clock */\rCLK-\u0026gt;AHBCLK0 |= CLK_AHBCLK0_GPACKEN_Msk | CLK_AHBCLK0_GPBCKEN_Msk | CLK_AHBCLK0_GPCCKEN_Msk | CLK_AHBCLK0_GPDCKEN_Msk |\rCLK_AHBCLK0_GPECKEN_Msk | CLK_AHBCLK0_GPFCKEN_Msk | CLK_AHBCLK0_GPGCKEN_Msk | CLK_AHBCLK0_GPHCKEN_Msk;\rCLK-\u0026gt;AHBCLK1 |= CLK_AHBCLK1_GPICKEN_Msk | CLK_AHBCLK1_GPJCKEN_Msk;\r/* Enable UART module clock */\rCLK_EnableModuleClock(UART0_MODULE);\rCLK_EnableModuleClock(UART1_MODULE);\r/* Select UART module clock source and UART module clock divider */\rCLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HIRC, CLK_CLKDIV0_UART0(1));\rCLK_SetModuleClock(UART1_MODULE, CLK_CLKSEL1_UART1SEL_HIRC, CLK_CLKDIV0_UART1(1));\r/*---------------------------------------------------------------------------------------------------------*/\r/* Init I/O Multi-function */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Set multi-function pins for UART0 RXD and TXD */\rSET_UART0_RXD_PB12();\rSET_UART0_TXD_PB13();\r/*---------------------------------------------------------------------------------------------------------*/\r/* Initialization for sample code */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Enable TIMER module clock */\rCLK_EnableModuleClock(TMR0_MODULE);\r/* Select TIMER clock source */\rCLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_HIRC, 0);\r}\rvoid UART0_Init(void)\r{\r/*---------------------------------------------------------------------------------------------------------*/\r/* Init UART */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Reset UART0 */\rSYS_ResetModule(UART0_RST);\r/* Configure UART0 and set UART0 baud rate */\rUART_Open(UART0, 115200);\r}\r/*---------------------------------------------------------------------------------------------------------*/\r/* Main Function */\r/*---------------------------------------------------------------------------------------------------------*/\rint32_t main(void)\r{\r/* Unlock protected registers */\rSYS_UnlockReg();\r/* Init System, peripheral clock and multi-function I/O */\rSYS_Init();\r/* Lock protected registers */\rSYS_LockReg();\r/* Init UART0 for printf */\rUART0_Init();\rGPIO_SetMode(PH, BIT4, GPIO_MODE_OUTPUT);\rprintf(\u0026#34;test \\n\u0026#34;);\rwhile(1) {\rPH4 = 1;\rTIMER_Delay(TIMER0, 1000000);\rPH4 = 0;\rTIMER_Delay(TIMER0, 1000000);\r}\r}\r/*---------------------------------------------------------------------------------------------------------*/\r/* ISR to handle UART Channel 0 interrupt event */\r/*---------------------------------------------------------------------------------------------------------*/\rvoid UART0_IRQHandler(void)\r{\rUART_TEST_HANDLE();\r}\r/*---------------------------------------------------------------------------------------------------------*/\r/* UART Callback function */\r/*---------------------------------------------------------------------------------------------------------*/\rvoid UART_TEST_HANDLE(void)\r{\ruint8_t u8InChar = 0xFF;\ruint32_t u32IntSts = UART0-\u0026gt;INTSTS;\rif(u32IntSts \u0026amp; UART_INTSTS_RDAINT_Msk)\r{\rprintf(\u0026#34;\\nInput:\u0026#34;);\r/* Get all the input characters */\rwhile(UART_IS_RX_READY(UART0))\r{\r/* Get the character from UART Buffer */\ru8InChar = (uint8_t)UART_READ(UART0);\rprintf(\u0026#34;%c \u0026#34;, u8InChar);\rif(u8InChar == \u0026#39;0\u0026#39;)\r{\rg_i32Wait = FALSE;\r}\r/* Check if buffer full */\rif(g_u32comRbytes \u0026lt; RXBUFSIZE)\r{\r/* Enqueue the character */\rg_u8RecData[g_u32comRtail] = u8InChar;\rg_u32comRtail = (g_u32comRtail == (RXBUFSIZE - 1)) ? 0 : (g_u32comRtail + 1);\rg_u32comRbytes++;\r}\r}\rprintf(\u0026#34;\\nTransmission Test:\u0026#34;);\r/* Forces a write of all user-space buffered data for the given output */\rfflush(stdout);\r}\rif(u32IntSts \u0026amp; UART_INTSTS_THREINT_Msk)\r{\ruint32_t u32Tmp;\ru32Tmp = g_u32comRtail;\rif(g_u32comRhead != u32Tmp)\r{\ru8InChar = g_u8RecData[g_u32comRhead];\rwhile(UART_IS_TX_FULL(UART0)); /* Wait Tx is not full to transmit data */\rUART_WRITE(UART0, u8InChar);\rg_u32comRhead = (g_u32comRhead == (RXBUFSIZE - 1)) ? 0 : (g_u32comRhead + 1);\rg_u32comRbytes--;\r}\r}\r/* Handle transmission error */\rif(UART0-\u0026gt;FIFOSTS \u0026amp; (UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk | UART_FIFOSTS_RXOVIF_Msk))\r{\rUART0-\u0026gt;FIFOSTS = (UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk | UART_FIFOSTS_RXOVIF_Msk);\r}\r}\r/*---------------------------------------------------------------------------------------------------------*/\r/* UART Function Test */\r/*---------------------------------------------------------------------------------------------------------*/\rvoid UART_FunctionTest(void)\r{\rprintf(\u0026#34;+-----------------------------------------------------------+\\n\u0026#34;);\rprintf(\u0026#34;| UART Function Test |\\n\u0026#34;);\rprintf(\u0026#34;+-----------------------------------------------------------+\\n\u0026#34;);\rprintf(\u0026#34;| Description : |\\n\u0026#34;);\rprintf(\u0026#34;| The sample code will print input char on terminal |\\n\u0026#34;);\rprintf(\u0026#34;| Please enter any to start (Press \u0026#39;0\u0026#39; to exit) |\\n\u0026#34;);\rprintf(\u0026#34;+-----------------------------------------------------------+\\n\u0026#34;);\r/*\rUsing a RS232 cable to connect UART0 and PC.\rUART0 is set to debug port. UART0 is enable RDA interrupt.\rWhen inputting char to terminal screen, RDA interrupt will happen and\rUART0 will print the received char on screen.\r*/\r/* Enable UART RDA and THRE interrupt */\rNVIC_EnableIRQ(UART0_IRQn);\rUART_EnableInt(UART0, (UART_INTEN_RDAIEN_Msk | UART_INTEN_THREIEN_Msk));\rwhile(g_i32Wait);\r/* Disable UART RDA and THRE interrupt */\rNVIC_DisableIRQ(UART0_IRQn);\rUART_DisableInt(UART0, (UART_INTEN_RDAIEN_Msk | UART_INTEN_THREIEN_Msk));\rg_i32Wait = TRUE;\r} ","permalink":"https://weizongchen.github.io/blog/timer_delay/","tags":["Cortex M4"],"title":"Timer Delay 說明 (by M460)"},{"categories":["說明文件"],"contents":"在Keil IDE 的 Debug Mode 時 Memory window data 突然不實時更新了?\n下圖 右邊的 Memory2 本來會一直更新，但是沒有?\n只要在 View下的 Periodic Window Update 打開就好\n如下影片操作\n","permalink":"https://weizongchen.github.io/blog/keil_debug_memoryupdate/","tags":["Cortex M4"],"title":"Keil IDE Debug Mode Memory window data not update?"},{"categories":["說明文件"],"contents":"Keil IDE 在啟動 project 時，會自己上網下載 一堆不是新唐的pack\n下圖看到時趕緊關掉，不然他會一直download 不是新唐的東西。\n這邊選\u0026quot;是\u0026quot; 跳過這裡\n這個時候，Keil會跟你說沒有這個M460的 pack 包，你如果不安裝 ，compile 也會過，但是每次打開Keil 會就跳出來，滿煩的。\n去新唐的官網，下載Driver 就可以解決這個問題了。\n新唐Driver 位置\nNu-Link_Keil_Driver_V3.09.7380r\n準備安裝\n這裡如果你不懂，就按照指示預設安裝路徑。\n這裡會出現這個視窗，是因為我原本就已經安裝過這個Driver，裡面有M480 NUC505 \u0026hellip; 一堆 但是不包含M460的部分，所以按\u0026quot;是\u0026quot;，就會更新成有包含460的\n這裡步驟就是安裝pack(Nuvoton device family pack)了 一路按\u0026quot;是\u0026quot; 就可以了\n他會把Nuvoton的pack都安裝\n因為我使用新唐的開發版，上面有Nu-Link2-Me 的燒錄器，所以當然也安裝一下它的driver，你如果是 J-Link 、U-Link 、巴拉巴拉Link\u0026hellip;，要自己安裝他們的Driver喔。\n安裝\n再次打開Project 就不會有那些警告視窗拉~\n","permalink":"https://weizongchen.github.io/blog/keil_import_pack/","tags":["Cortex M4"],"title":"Keil IDE 在啟動 project 時，會自己上網下載 一堆不是新唐的pack"},{"categories":["說明文件"],"contents":"如果你不是商業使用 !\n如果你不是商業使用 !\n如果你不是商業使用 !\n很重要所以說三次! 所以如果你是個人評估使用\nARM 對這個 MDK-Community 說明\n簡單說就是支援 : All microcontrollers based on Arm Cortex®-M processors\n你給他E mail 它就給你licence\n把上面 LIC 填到下面\n","permalink":"https://weizongchen.github.io/blog/keil_ide_licence/","tags":["Cortex M4"],"title":"Keil IDE 16K Code size 限制?"},{"categories":["說明文件"],"contents":" 可以直接來這邊下載 https://www.nuvoton.com/tool-and-software/debugger-and-programmer/mass-production-tool/\nICP Tool 新唐燒錄器適用於新唐NuMicro®微控制器的大量生產階段。基於靈活的設定與直觀的操作，使用者可全面掌握量產流程。\n選擇你的series\n如果你電腦插著很多個NuLnk 可以選，點選Radio Button時，那個被指定的NuLnk會閃閃閃閃閃~\n如果你電腦灌過ICP 軟體了，跟這板子原本的ICP版本不匹配，你可以更新，也可以不更新，一般我都直接不更新，反正可以燒就好。\n因為我是要把板子上的APROM的 firmware拿出來存，可以照下圖的方式點選\n最後成功存取\nFile Data 要燒進去板子的FW版本\nOn board flash 板子上面的FW版本\nOffline Flash 在燒入除錯器裡面的版本\n","permalink":"https://weizongchen.github.io/blog/icp_introduce/","tags":["Tool"],"title":"ICP 使用說明"},{"categories":["說明文件"],"contents":" User Manual https://www.nuvoton.com/export/resource-files/UM_NuMaker-ETM-M487_User_Manual_EN_Rev1.01.pdf\n通用 I/O (GPIO) 概述 M480 系列多達118 個通用I/O管腳和其他功能管腳共享，這取決於芯片的配置。 118個管腳分配在PA, PB, PC, PD, PE, PF, PG 和 PH這8個端口上。 PA, PB, PE和PG有16個管腳，PC，PD有15個管腳，PF，PH有12個管腳。每個管腳都是獨立的，都有相應的寄存器位來控制管腳功能模式與數據。\n1. 設定發電廠 (clock) 2. 設定 LED 的腳位 General Port 0~7 為 Low byte, 8~15 為 High byte 所以是Port H 的 0 1 2 是L，如下面黃色的標記\n設定 Port H 0 1 2 腳位為 output\n3. 設定 Button 的腳位 General Port 0~7 為 Low byte, 8~15 為 High byte 所以是Port B 的 15 是H , Port F 的 11 是H，如下面黃色的標記\n設定 Port B 15 和 Port F 11 腳位為 input\n4. 設定 UART0 的腳位 新唐大部分的M4 UART0 腳位是 PB12 RXD / PB13 TXD\n5. 設定中斷 這邊中斷就是用UART0 打印東西，和 toggle LED 的亮滅\n完整程式參考 /**************************************************************************//**\r* @file main.c\r* @version V3.00\r* @brief GPIO function for level1 training course\r*\r******************************************************************************/\r#include \u0026lt;stdio.h\u0026gt;\r#include \u0026#34;NuMicro.h\u0026#34;\r#define LED_R\tPH0\r#define LED_G\tPH1\r#define LED_B\tPH2\r#define LED_ON\t0\r#define LED_OFF\t1\rvolatile uint32_t sw1_int_cnt = 0;\rvolatile uint32_t sw2_int_cnt = 0;\rvoid SYS_Init(void)\r{\r/* Enable HXT clock (external XTAL 12MHz) */\rCLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);\r/* Wait for HXT clock ready */\rCLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);\r/* Enable LIRC clock */\rCLK_EnableXtalRC(CLK_PWRCTL_LIRCEN_Msk);\r/* Wait for LIRC clock ready */\rCLK_WaitClockReady(CLK_STATUS_LIRCSTB_Msk);\r/* Set core clock as PLL_CLOCK from PLL */\rCLK_SetCoreClock(FREQ_192MHZ);\r/* Set PCLK0/PCLK1 to HCLK/2 */\rCLK-\u0026gt;PCLKDIV = (CLK_PCLKDIV_PCLK0DIV2 | CLK_PCLKDIV_PCLK1DIV2);\r/* Enable module clock */\rCLK_EnableModuleClock(UART0_MODULE);\r/* Set module clock */\rCLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HXT, CLK_CLKDIV0_UART0(1));\r}\rvoid UART0_Init()\r{\r/* Set GPB multi-function pins to UART0 RXD and TXD */\rSYS-\u0026gt;GPB_MFPH = (SYS-\u0026gt;GPB_MFPH \u0026amp; ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk)) |\r(SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);\r/* Configure UART0 and set UART0 baud rate */\rUART_Open(UART0, 115200);\r}\rvoid LED_Init(void)\r{\r/* Set PH.0 ~ PH.2 to GPIO */\rSYS-\u0026gt;GPH_MFPL = (SYS-\u0026gt;GPH_MFPL \u0026amp; ~(SYS_GPH_MFPL_PH0MFP_Msk | SYS_GPH_MFPL_PH1MFP_Msk | SYS_GPH_MFPL_PH2MFP_Msk)) |\r(SYS_GPH_MFPL_PH0MFP_GPIO | SYS_GPH_MFPL_PH1MFP_GPIO | SYS_GPH_MFPL_PH2MFP_GPIO);\r/* Set PC.9 ~ PC.11 to GPIO output */\rGPIO_SetMode(PH, (BIT0 | BIT1 | BIT2), GPIO_MODE_OUTPUT);\r/* Let LED off after initialize */\rLED_R = LED_OFF;\rLED_G = LED_OFF;\rLED_B = LED_OFF;\r}\rvoid BTN_Init(void)\r{\r/************** SW2 ***************/\r/* Set PB.15 to GPIO */\rSYS-\u0026gt;GPG_MFPH = (SYS-\u0026gt;GPG_MFPH \u0026amp; ~(SYS_GPG_MFPH_PG15MFP_Msk)) | (SYS_GPG_MFPH_PG15MFP_GPIO);\r/* Set PB.15 to GPIO intput */\rGPIO_SetMode(PG, BIT15, GPIO_MODE_INPUT);\rGPIO_EnableInt(PG, 15, GPIO_INT_FALLING);\rNVIC_EnableIRQ(GPG_IRQn);\r/************** SW3 ***************/\r/* Set PF.11 to GPIO */\rSYS-\u0026gt;GPF_MFPH = (SYS-\u0026gt;GPF_MFPH \u0026amp; ~(SYS_GPF_MFPH_PF11MFP_Msk)) | (SYS_GPF_MFPH_PF11MFP_GPIO);\r/* Set PF.11 to GPIO intput */\rGPIO_SetMode(PF, BIT11, GPIO_MODE_INPUT);\rGPIO_EnableInt(PF, 11, GPIO_INT_FALLING);\rNVIC_EnableIRQ(GPF_IRQn);\r/* Set de-bounce function */\rGPIO_SET_DEBOUNCE_TIME(GPIO_DBCTL_DBCLKSRC_LIRC, GPIO_DBCTL_DBCLKSEL_512);\rGPIO_ENABLE_DEBOUNCE(PG, BIT15);\rGPIO_ENABLE_DEBOUNCE(PF, BIT11);\r}\rint main(void)\r{\ruint32_t sw1_cnt = 0, sw2_cnt = 0;\r/* Unlock protected registers */\rSYS_UnlockReg();\r/* Init System, peripheral clock and multi-function I/O */\rSYS_Init();\r/* Lock protected registers */\rSYS_LockReg();\r/* Init UART0 for printf */\rUART0_Init();\rprintf(\u0026#34;+---------------------------------------+\\n\u0026#34;);\rprintf(\u0026#34;| Level1 GPIO control Sample Code |\\n\u0026#34;);\rprintf(\u0026#34;+---------------------------------------+\\n\\n\u0026#34;);\r/* Init LED */\rLED_Init();\r/* Init BTN */\rBTN_Init();\rwhile(1) {\r/* Check if the SW1 is pressed */\rif (sw1_int_cnt != sw1_cnt) {\rsw1_cnt = sw1_int_cnt;\rprintf(\u0026#34;SW1 interrupt count: %d\\n\u0026#34;, sw1_cnt);\r}\r/* Check if the SW2 is pressed */\rif (sw2_int_cnt != sw2_cnt) {\rsw2_cnt = sw2_int_cnt;\rprintf(\u0026#34;SW2 interrupt count: %d\\n\u0026#34;, sw2_cnt);\r}\r}\r}\r//PG15\rvoid GPG_IRQHandler(void)\r{\rprintf(\u0026#34;+---------------------------------------+\\n\u0026#34;);\rprintf(\u0026#34;+------------Detect PG---------------+\\n\u0026#34;);\rprintf(\u0026#34;+---------------------------------------+\\n\u0026#34;);\r/* Check if PG.15 the interrupt occurred */\rif(GPIO_GET_INT_FLAG(PG, BIT15)) {\rLED_R ^= 1;\rsw1_int_cnt++;\r/* Clear PG.15 interrupt flag */\rGPIO_CLR_INT_FLAG(PG, BIT15);\r}else {\r/* Un-expected interrupt. Just clear all PB interrupts */\rPG-\u0026gt;INTSRC = PG-\u0026gt;INTSRC;\rprintf(\u0026#34;Un-expected interrupts.\\n\u0026#34;);\r}\r}\r//PF11\rvoid GPF_IRQHandler(void)\r{\rprintf(\u0026#34;+---------------------------------------+\\n\u0026#34;);\rprintf(\u0026#34;+------------Detect PF---------------+\\n\u0026#34;);\rprintf(\u0026#34;+---------------------------------------+\\n\u0026#34;);\r/* Check if PF.11 the interrupt occurred */\rif(GPIO_GET_INT_FLAG(PF, BIT11)) {\rLED_G ^= 1;\rsw2_int_cnt++;\r/* Clear PF.11 interrupt flag */\rGPIO_CLR_INT_FLAG(PF, BIT11);\r} else {\r/* Un-expected interrupt. Just clear all PB interrupts */\rPF-\u0026gt;INTSRC = PF-\u0026gt;INTSRC;\rprintf(\u0026#34;Un-expected interrupts.\\n\u0026#34;);\r}\r} M460 的控制LED範例 /*---------------------------------------------------------------------------------------------------------*/\r/* Main Function */\r/*---------------------------------------------------------------------------------------------------------*/\rint32_t main(void)\r{\r//Mode\r*(volatile unsigned int *)(0x400041C0) = 0x00001500;\r//value\r*(volatile unsigned int *)(0x400041C8) = 0x0000FF8F;\rwhile(1) {\rint i;\rfor(i = 0; i \u0026lt; 50000000; i++) {} //等1下\r*(volatile unsigned int *)(0x400041C8) = 0x00000000;\rfor(i = 0; i \u0026lt; 50000000; i++) {} //等1下\r*(volatile unsigned int *)(0x400041C8) = 0x00000070;\r}\r} *(volatile unsigned int *)(0x400041C0) = 0x00001500;\nRegister 位置\n0x40004000 + 0x1C0\nRegister的值\n0x 0000 1500\n000\u0026hellip;0 1500 如下圖\n*(volatile unsigned int *)(0x400041C8) = 0x00000070;\n0x1C8 是 PH_DOUT (port H out) 的控制\n70 如下圖所示 (0x00000070 全滅 0x00000000 全亮)\nint32_t main(void)\r{\r//Mode\r*(volatile unsigned int *)(0x400041C0) = 0x00001500;\rGPIO_SetMode(PH, BIT4, GPIO_MODE_OUTPUT);\r//value\r*(volatile unsigned int *)(0x400041C8) = 0x00000000;\rGPIO_SetMode(PH, BIT4, GPIO_MODE_OUTPUT);\rPH4 = 0;\rPH5 = 0;\rPH6 = 0;\rwhile(1) {\rint i;\rfor(i = 0; i \u0026lt; 50000000; i++) {} //等1百萬下\r// 全滅\r//*(volatile unsigned int *)(0x400041C8) = 0x00000000;\rPH4 = 1;\rPH5 = 1;\rPH6 = 1;\rfor(i = 0; i \u0026lt; 50000000; i++) {} //等1百萬下\r// 全亮\rPH4 = 0;\rPH5 = 0;\rPH6 = 0;\r}\r} M460 的控制Button範例 /**************************************************************************//**\r* @file main.c\r* @version V3.00\r* @brief Show the usage of GPIO interrupt function.\r*\r* @copyright SPDX-License-Identifier: Apache-2.0\r* @copyright Copyright (C) 2021 Nuvoton Technology Corp. All rights reserved.\r******************************************************************************/\r#include \u0026lt;stdio.h\u0026gt;\r#include \u0026#34;NuMicro.h\u0026#34;\rvoid GPH_IRQHandler(void);\rvoid SYS_Init(void);\rvoid UART0_Init(void);\r/**\r* @brief GPIO PH IRQ\r*\r* @param None\r*\r* @return None\r*\r* @details The PH default IRQ, declared in startup_m460.s.\r*/\rvoid GPH_IRQHandler(void)\r{\rvolatile uint32_t u32temp;\r/* To check if PH.0 interrupt occurred */\rif(GPIO_GET_INT_FLAG(PH, BIT0))\r{\rGPIO_CLR_INT_FLAG(PH, BIT0);\rprintf(\u0026#34;PH.0 INT occurred.\\n\u0026#34;);\r}\relse if(GPIO_GET_INT_FLAG(PH, BIT1))\r{\rGPIO_CLR_INT_FLAG(PH, BIT1);\rprintf(\u0026#34;PH.1 INT occurred.\\n\u0026#34;);\r}\relse\r{\r/* Un-expected interrupt. Just clear all PH interrupts */\ru32temp = PH-\u0026gt;INTSRC;\rPH-\u0026gt;INTSRC = u32temp;\rprintf(\u0026#34;Un-expected interrupts.\\n\u0026#34;);\r}\r}\rvoid SYS_Init(void)\r{\r/*---------------------------------------------------------------------------------------------------------*/\r/* Init System Clock */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Set PCLK0 and PCLK1 to HCLK/2 */\rCLK-\u0026gt;PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);\r/* Set core clock to 200MHz */\rCLK_SetCoreClock(200000000);\r/* Enable all GPIO clock */\rCLK-\u0026gt;AHBCLK0 |= CLK_AHBCLK0_GPACKEN_Msk | CLK_AHBCLK0_GPBCKEN_Msk | CLK_AHBCLK0_GPCCKEN_Msk | CLK_AHBCLK0_GPDCKEN_Msk |\rCLK_AHBCLK0_GPECKEN_Msk | CLK_AHBCLK0_GPFCKEN_Msk | CLK_AHBCLK0_GPGCKEN_Msk | CLK_AHBCLK0_GPHCKEN_Msk;\rCLK-\u0026gt;AHBCLK1 |= CLK_AHBCLK1_GPICKEN_Msk | CLK_AHBCLK1_GPJCKEN_Msk;\r/* Enable UART0 module clock */\rCLK_EnableModuleClock(UART0_MODULE);\r/* Select UART0 module clock source as HIRC and UART0 module clock divider as 1 */\rCLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HIRC, CLK_CLKDIV0_UART0(1));\r/*---------------------------------------------------------------------------------------------------------*/\r/* Init I/O Multi-function */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Set multi-function pins for UART0 RXD and TXD */\rSET_UART0_RXD_PB12();\rSET_UART0_TXD_PB13();\r}\rvoid UART0_Init(void)\r{\r/*---------------------------------------------------------------------------------------------------------*/\r/* Init UART */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Reset UART0 */\rSYS_ResetModule(UART0_RST);\r/* Configure UART0 and set UART0 baud rate */\rUART_Open(UART0, 115200);\r}\r/*---------------------------------------------------------------------------------------------------------*/\r/* Main Function */\r/*---------------------------------------------------------------------------------------------------------*/\rint32_t main(void)\r{\r/* Unlock protected registers */\rSYS_UnlockReg();\r/* Init System, peripheral clock and multi-function I/O */\rSYS_Init();\r/* Lock protected registers */\rSYS_LockReg();\r/* Init UART0 for printf */\rUART0_Init();\rprintf(\u0026#34;\\n\\nCPU @ %d Hz\\n\u0026#34;, SystemCoreClock);\rprintf(\u0026#34;+------------------------------------------------+\\n\u0026#34;);\rprintf(\u0026#34;| GPIO PH.0 and PH.1 Interrupt Sample Code |\\n\u0026#34;);\rprintf(\u0026#34;+------------------------------------------------+\\n\\n\u0026#34;);\r/*-----------------------------------------------------------------------------------------------------*/\r/* GPIO Interrupt Function Test */\r/*-----------------------------------------------------------------------------------------------------*/\rprintf(\u0026#34;PH.0 and PH.1 are used to test interrupt ......\\n\u0026#34;);\r/* Configure PH.0 as Input mode and enable interrupt by rising edge trigger */\rGPIO_SetMode(PH, BIT0, GPIO_MODE_INPUT);\rGPIO_EnableInt(PH, 0, GPIO_INT_RISING);\rNVIC_EnableIRQ(GPH_IRQn);\r/* Configure PH.1 as Quasi-bidirection mode and enable interrupt by falling edge trigger */\rGPIO_SetMode(PH, BIT1, GPIO_MODE_QUASI);\rGPIO_EnableInt(PH, 1, GPIO_INT_FALLING);\rNVIC_EnableIRQ(GPH_IRQn);\r/* Enable interrupt de-bounce function and select de-bounce sampling cycle time is 1024 clocks of LIRC clock */\rGPIO_SET_DEBOUNCE_TIME(PH, GPIO_DBCTL_DBCLKSRC_LIRC, GPIO_DBCTL_DBCLKSEL_1024);\rGPIO_SET_DEBOUNCE_TIME(PH, GPIO_DBCTL_DBCLKSRC_LIRC, GPIO_DBCTL_DBCLKSEL_1024);\rGPIO_ENABLE_DEBOUNCE(PH, BIT0);\rGPIO_ENABLE_DEBOUNCE(PH, BIT1);\r/* Waiting for interrupts */\rwhile(1);\r} ","permalink":"https://weizongchen.github.io/blog/gpio_introduce/","tags":["Cortex M4"],"title":"GPIO 說明"},{"categories":["安裝步驟文件"],"contents":"Description Enable the Remoteproc device driver in the Linux kernel.\n$ bitbake linux-ma35d1 -c menuconfig Device Drivers ---\u0026gt;\rRemoteproc drivers ---\u0026gt;\r[*] Support for Remote Processor subsystem\r\u0026lt;*\u0026gt; MA35D1 remoteproc support \u0026lt;Save\u0026gt; and \u0026lt;Exit\u0026gt; Description Modify the device tree node setting of remoteproc in the Linux kernel.\nLINUX_KERENL_PATH/arch/arm64/boot/dts/nuvoton/ma35d1.dtsi Description Compile the Linux kernel.\n$ bitbake linux-ma35d1 -C compile Description Modify the device tree node setting of SSPCC in the TF-A. 怎麼知道是I2S0_SUBM的?\nDescription Modify the device tree node setting of SSPCC in the TF-A. 怎麼知道是這4根pin角的?\nDescription Compile the TF-A.\n$ bitbake tf-a-ma35d1 -C compile Description Build-up Image. Qt 版本:\nbitbake nvt-image-qt5 -c cleanall \u0026amp;\u0026amp; bitbake nvt-image-qt5 Minimal 版本:\n$ bitbake core-image-minimal –c cleanall \u0026amp;\u0026amp; bitbake core-image-minimal Description Burn-in Image into SD card. 燒入SD卡\n$ sudo dd if=nvt-image-qt5-evb-ma35d1-xxxxx.rootfs.sdcard of=/dev/sdb 延展SD的size\rsudo ./ma35d1_resize.sh /dev/sdb 1 apply 把 M4 的.axf 放到SD卡的 /lib/firmware 中\nNote: The following step copy all of RTP (M4) sample codes in the M4_BSP into Filesystem. You can chose the sample code you want to use or replace with the firmware you developed. 執行 M4 axf 的指令\necho -n /lib/firmware \u0026gt; /sys/module/firmware_class/parameters/path\recho -n I2S_Codec_PDMA.elf \u0026gt; /sys/class/remoteproc/remoteproc0/firmware\recho start \u0026gt; /sys/class/remoteproc/remoteproc0/state\recho stop \u0026gt; /sys/class/remoteproc/remoteproc0/state Remoteproc - Keil IDE 設定\nNu-link 的DAP 要設定1\nPS:原本我們開發板的NuLink 是 0 ，MA35D1的要改1 ","permalink":"https://weizongchen.github.io/blog/ma35d1_rtp/","tags":["MA35D1","Cortex M4"],"title":"MA35D1 M4 使用設定"},{"categories":["安裝步驟文件"],"contents":"MA35D16A887C (BGA312) MCP package with DDR3L (256 MB)\n7-inch TFT LCD (1024x600) with touch daughter board\neMMC memory device daughter board\nSPI-NAND flash W25N02JWZEIF (256MB)\nNAND flash W29N01HVS1NA (128MB)\n2 x Giga Ethernet\n2 x High Speed USB\n2 x Camera Capture (CMOS sensor) header connectors\n1 x SIM Card slot\n2 x UART, 2 x RS485, 2 x CAN-FD, 8 x EADC channels\n基本安裝設定 Yocto 項目至少需要 150G 存儲\n在使用 Yocto 項目之前必須安裝必要的包\n$ sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib \\\rbuild-essential chrpath socat cpio python python3 python3-pip python3-pexpect \\\rxz-utils debianutils iputils-ping libsdl1.2-dev xterm curl Update existing list of packages\n$ sudo apt-get update Install a few prerequisite packages which let apt use packages over HTTPS\n$ sudo apt install apt-transport-https ca-certificates curl software-properties-common Add Docker’s official GPG key for the official Docker repository to your system\n$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add Set up the stable repository, add the Docker repository to APT sources\n$ sudo add-apt-repository \u0026#34;deb [arch=amd64] https://download.docker.com/linux/ubuntu focal stable\u0026#34; Update the package database with the Docker packages from the newly added repo\n$ sudo apt-get update Install Docker\n$ sudo apt-get install docker-ce docker-ce-cli containerd.io Download the Docker Script for MA35D1\n$ git clone https://github.com/OpenNuvoton/MA35D1_Docker_Script.git Enter docker-yocto folder, setup docker image, and select folder to be share\n$ ./build.sh It may take one hour to get 710 files.\rPlease enter absolute path for shared folders(eg:/home/\u0026lt;user name\u0026gt;) : Enter docker image, and your command line head will be like nuvoton@a24d9e06abe3:~$\n$ ./join.sh\rnua3500_nuvoton\rnuvoton@a24d9e06abe3:~$ Create a folder name yocto under /share\nnuvoton@a24d9e06abe3:~/share$ mkdir yocto The first time you use repo, you need to set up the GIT environment\nnuvoton@a24d9e06abe3:~/share/yocto$ git config --global user.email \u0026#34;test@test.test.test\u0026#34;\rnuvoton@a24d9e06abe3:~/share/yocto$ git config --global user.name \u0026#34;test“\rnuvoton@a24d9e06abe3:~/share/yocto$ git config --global http.sslverify false Go to /share/yocto to setup repo path\nnuvoton@a24d9e06abe3:~/share/yocto$ repo init -u https://github.com/OpenNuvoton/MA35D1_Yocto-v3.1.3.git -m meta-ma35d1/base/ma35d1.xml Download the yocto project\nnuvoton@a24d9e06abe3:~/share/yocto$ repo sync Build Image by Yocto Setup building configuration. The DISTRO option we usually use nvt-ma35d1-directfb\nEVB :\n~/yocto$ DISTRO=nvt-ma35d1-directfb MACHINE=ma35d1-evb source sources/init-build-env build SOM :\n~/yocto$ DISTRO=nvt-ma35d1-directfb MACHINE=numaker-som-ma35d16a81 source sources/init-build-env build MACHINE 目前有 SOM 板 或 IOT 板，後面ma35d16a81是 板號，所以客戶可以做他自己的板子，用自己得板號。\nMACHINE=numaker-som-ma35d16a81\nMACHINE=numaker-iot-ma35d16f70 ( f7 =\u0026gt; DDR 128MB )\nMACHINE=numaker-iot-ma35d16f90 ( f9 =\u0026gt; DDR 512MB )\ntest chip SOM :\n~/yocto$ DISTRO=nvt-ma35d1-directfb MACHINE=ma35d1-tc-som source sources/init-build-env build (補充說明) 假設我要改build 不同的板號，從numaker-som-ma35d16a81 改成 numaker-iot-ma35d16f70，有兩個地方要改 local.conf 的 Machine 要改如下 指定編譯 DISTRO=nvt-ma35d1-directfb MACHINE=numaker-iot-ma35d16f70 source sources/init-build-env build Choose what Image you want to build\nImage 包含Qt的版本 (建議)\nbitbake nvt-image-qt5 小 Image 版本\nbitbake core-image-minimal Copy the image to SD $ sudo dd if=nvt-image-qt5-evb-ma35d1-xxxxx.rootfs.sdcard of=/dev/sdb Fast Application Development Make a toolchain installer\n$ bitbake nvt-image-qt5 -c populate_sdk\r(This may take about 1 hour ) Go to the following path and execute the shell file\n~build/tmp-glibc/deploy/sdk $ ./oecore-x86_x64-aarch64-toolcahin-5.5-dunfell.sh Add toolchain to environment variables\n$ source /usr/local/oecore-x86_64/environment-setup-aarch64-poky-linux Create the source code file for this example: helloworld.c\n#include \u0026lt;stdio.h\u0026gt;\rint main() {\r// printf() displays the string inside console\rprintf(“Hello, World!\\n”);\rreturn 0;\r} Compile it\n$ $CC helloworld.c -o helloworld ","permalink":"https://weizongchen.github.io/blog/ma35d1_install_method/","tags":["MA35D1"],"title":"MA35D1 Yocto 安裝說明"},{"categories":["說明文件"],"contents":" 要找這個Register\n問這個PDBIASEN bit 找不到\u0026hellip;..\nCLK-\u0026gt;LDOCTL |= CLK_LDOCTL_PDBIASEN_Msk;\nClock, LDO control Rigister, PDBIASEN 這個 bit\nbit 18\n忘記在哪一版本TRM 有找到這個register\n右邊表格˙(1) (2) 沒有賣了，所以只是給過去參考，目前就是看(3) 就好~\nCore Coupled Memory Mode (CCM Mode)\nCCM Mode 是 SRAM 跟 SPI Flash 的關係，SPI Flash可以把SRAM當作catch來使用，\nCCMEN 打開 就是一般SRAM，不是catch\nWhen user sets CCMEN(SPIM_CTL1[2]) to 1, the operation mode of cache memory will be core coupled memory mode (CCM mode). In CCM mode, the cache function of SPI Flash controller is disabled by hardware automatically, and MCU can access this core coupled memory as general SRAM. When user sets CCMEN(SPIM_CTL1[2]) to 0 and MCU accesses CCM address range, SPI Flash controller will generate AHB error response to MCU.\n當用戶設置CCMEN(SPIM_CTL1[2])為1時，緩存存儲器操作模式會轉變成內核耦合存儲器模式(CCM模 式)。在CCM模式下，SPI flash控制器的緩存功能會被硬件自動禁用，MCU訪問內核耦合存儲器就像是 SRAM一樣。當用戶設置CCMEN(SPIM_CTL1[2])為0時MCU訪問CCM地址範圍，SPI flash控制器將會 產生AHB錯誤給MCU\n","permalink":"https://weizongchen.github.io/blog/question/","tags":null,"title":"自己的問題筆記"},{"categories":["安裝步驟文件"],"contents":"系統環境 Windows 10 VS 2019 OpenCV 4.5.5 選擇 Windows 版本的OpenCV download下來 解壓縮到指定資料夾 可以在C 根目錄建一個 OpenCV 資料夾，在OpenCV資料夾下再建一個OpenCV4.5.5資料夾，並解押到這裡面\n整理檔案位置，將需要的檔案拿出來就好 因為opencv資料夾的大小很大，可以刪除。如空間夠大可以留下來，以備不時之需。\nbin 資料夾說明 opencv 3 版本之後，只需要opencv_world455.dll就可以了，opencv_world455d.dll 多一個d是指 debug版本的意思。\n設定環境變數 建立一個空的C++專案 建立一個空的C++專案 在這裡應該有solution 和 project 的分別，我們要在solution的位置新增一個專案 建立屬性管理員 Property Manager 方便每次專案可以套用同一個屬性，比如哪天出了opencv新的版本，可以直接套用新的版本的opencv或使用更舊版本的opencv 去view打開屬姓管理員，預設是沒有顯示的。 使用x64的Release版本\n建一個有意義的名子，給x64、opencv版本是455、Release的版本使用的property 已產生此版本的屬性，待會就用這個屬性設定opencv的變數\n使用 Property Manager 設定OpenCV的環境 記得因為我們是使用 Release x64 版本的屬性所以上面要改一下\n基本上打到第2層，就會有提示字出現之後，就表示設定成功了，設定一下起始專案。\n寫一個簡單的程式測試一下 opencv 的設定 // loadimg.cpp : 此檔案包含 \u0026#39;main\u0026#39; 函式。程式會於該處開始執行及結束執行。\r//\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;opencv2/core/core.hpp\u0026gt;\r#include \u0026lt;opencv2/highgui/highgui.hpp\u0026gt;\rusing namespace std;\rusing namespace cv;\rint main()\r{\rMat img;\rimg = imread(\u0026#34;C:\\\\Users\\\\b51ak\\\\Pictures\\\\promotion.png\u0026#34;);\rnamedWindow(\u0026#34;figure 1\u0026#34;, WINDOW_AUTOSIZE);\rimshow(\u0026#34;figure 1\u0026#34;, img);\rstd::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\\n\u0026#34;;\rwaitKey(0);\rreturn 0;\r} ","permalink":"https://weizongchen.github.io/blog/opencv_env/","tags":["OpenCV"],"title":"OpenCV 環境安裝"}]