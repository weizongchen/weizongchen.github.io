[{"categories":["說明文件"],"contents":"加入Timer的Driver 在 SYS_Init() 時 ，加入TMR0 的 clock source /*---------------------------------------------------------------------------------------------------------*/\r/* Initialization for sample code */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Enable TIMER module clock */\rCLK_EnableModuleClock(TMR0_MODULE);\r/* Select TIMER clock source */\rCLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_HIRC, 0); 在 SYS_Init() 時 ，加入TMR0 的 clock source while(1) {\rPH4 = 1;\rTIMER_Delay(TIMER0, 1000000);\rPH4 = 0;\rTIMER_Delay(TIMER0, 1000000);\r} 邏輯分析儀量測 LED 訊號 用 Timer0 控制 LED 1秒亮 1秒滅 /**************************************************************************//**\r* @file main.c\r* @version V3.00\r* @brief Transmit and receive data from PC terminal through RS232 interface.\r*\r* @copyright SPDX-License-Identifier: Apache-2.0\r* @copyright Copyright (C) 2021 Nuvoton Technology Corp. All rights reserved.\r******************************************************************************/\r#include \u0026lt;stdio.h\u0026gt;\r#include \u0026#34;NuMicro.h\u0026#34;\r#define RXBUFSIZE 1024\r/*---------------------------------------------------------------------------------------------------------*/\r/* Global variables */\r/*---------------------------------------------------------------------------------------------------------*/\rstatic uint8_t g_u8RecData[RXBUFSIZE] = {0};\rstatic volatile uint32_t g_u32comRbytes = 0;\rstatic volatile uint32_t g_u32comRhead = 0;\rstatic volatile uint32_t g_u32comRtail = 0;\rstatic volatile int32_t g_i32Wait = TRUE;\r/*---------------------------------------------------------------------------------------------------------*/\r/* Define functions prototype */\r/*---------------------------------------------------------------------------------------------------------*/\rint32_t main(void);\rvoid UART_TEST_HANDLE(void);\rvoid UART_FunctionTest(void);\rvoid SYS_Init(void);\rvoid UART0_Init(void);\rvoid UART0_IRQHandler(void);\rvoid SYS_Init(void)\r{\r/*---------------------------------------------------------------------------------------------------------*/\r/* Init System Clock */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Set PCLK0 and PCLK1 to HCLK/2 */\rCLK-\u0026gt;PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);\r/* Set core clock to 200MHz */\rCLK_SetCoreClock(200000000);\r/* Enable all GPIO clock */\rCLK-\u0026gt;AHBCLK0 |= CLK_AHBCLK0_GPACKEN_Msk | CLK_AHBCLK0_GPBCKEN_Msk | CLK_AHBCLK0_GPCCKEN_Msk | CLK_AHBCLK0_GPDCKEN_Msk |\rCLK_AHBCLK0_GPECKEN_Msk | CLK_AHBCLK0_GPFCKEN_Msk | CLK_AHBCLK0_GPGCKEN_Msk | CLK_AHBCLK0_GPHCKEN_Msk;\rCLK-\u0026gt;AHBCLK1 |= CLK_AHBCLK1_GPICKEN_Msk | CLK_AHBCLK1_GPJCKEN_Msk;\r/* Enable UART module clock */\rCLK_EnableModuleClock(UART0_MODULE);\rCLK_EnableModuleClock(UART1_MODULE);\r/* Select UART module clock source and UART module clock divider */\rCLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HIRC, CLK_CLKDIV0_UART0(1));\rCLK_SetModuleClock(UART1_MODULE, CLK_CLKSEL1_UART1SEL_HIRC, CLK_CLKDIV0_UART1(1));\r/*---------------------------------------------------------------------------------------------------------*/\r/* Init I/O Multi-function */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Set multi-function pins for UART0 RXD and TXD */\rSET_UART0_RXD_PB12();\rSET_UART0_TXD_PB13();\r/*---------------------------------------------------------------------------------------------------------*/\r/* Initialization for sample code */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Enable TIMER module clock */\rCLK_EnableModuleClock(TMR0_MODULE);\r/* Select TIMER clock source */\rCLK_SetModuleClock(TMR0_MODULE, CLK_CLKSEL1_TMR0SEL_HIRC, 0);\r}\rvoid UART0_Init(void)\r{\r/*---------------------------------------------------------------------------------------------------------*/\r/* Init UART */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Reset UART0 */\rSYS_ResetModule(UART0_RST);\r/* Configure UART0 and set UART0 baud rate */\rUART_Open(UART0, 115200);\r}\r/*---------------------------------------------------------------------------------------------------------*/\r/* Main Function */\r/*---------------------------------------------------------------------------------------------------------*/\rint32_t main(void)\r{\r/* Unlock protected registers */\rSYS_UnlockReg();\r/* Init System, peripheral clock and multi-function I/O */\rSYS_Init();\r/* Lock protected registers */\rSYS_LockReg();\r/* Init UART0 for printf */\rUART0_Init();\rGPIO_SetMode(PH, BIT4, GPIO_MODE_OUTPUT);\rprintf(\u0026#34;test \\n\u0026#34;);\rwhile(1) {\rPH4 = 1;\rTIMER_Delay(TIMER0, 1000000);\rPH4 = 0;\rTIMER_Delay(TIMER0, 1000000);\r}\r}\r/*---------------------------------------------------------------------------------------------------------*/\r/* ISR to handle UART Channel 0 interrupt event */\r/*---------------------------------------------------------------------------------------------------------*/\rvoid UART0_IRQHandler(void)\r{\rUART_TEST_HANDLE();\r}\r/*---------------------------------------------------------------------------------------------------------*/\r/* UART Callback function */\r/*---------------------------------------------------------------------------------------------------------*/\rvoid UART_TEST_HANDLE(void)\r{\ruint8_t u8InChar = 0xFF;\ruint32_t u32IntSts = UART0-\u0026gt;INTSTS;\rif(u32IntSts \u0026amp; UART_INTSTS_RDAINT_Msk)\r{\rprintf(\u0026#34;\\nInput:\u0026#34;);\r/* Get all the input characters */\rwhile(UART_IS_RX_READY(UART0))\r{\r/* Get the character from UART Buffer */\ru8InChar = (uint8_t)UART_READ(UART0);\rprintf(\u0026#34;%c \u0026#34;, u8InChar);\rif(u8InChar == \u0026#39;0\u0026#39;)\r{\rg_i32Wait = FALSE;\r}\r/* Check if buffer full */\rif(g_u32comRbytes \u0026lt; RXBUFSIZE)\r{\r/* Enqueue the character */\rg_u8RecData[g_u32comRtail] = u8InChar;\rg_u32comRtail = (g_u32comRtail == (RXBUFSIZE - 1)) ? 0 : (g_u32comRtail + 1);\rg_u32comRbytes++;\r}\r}\rprintf(\u0026#34;\\nTransmission Test:\u0026#34;);\r/* Forces a write of all user-space buffered data for the given output */\rfflush(stdout);\r}\rif(u32IntSts \u0026amp; UART_INTSTS_THREINT_Msk)\r{\ruint32_t u32Tmp;\ru32Tmp = g_u32comRtail;\rif(g_u32comRhead != u32Tmp)\r{\ru8InChar = g_u8RecData[g_u32comRhead];\rwhile(UART_IS_TX_FULL(UART0)); /* Wait Tx is not full to transmit data */\rUART_WRITE(UART0, u8InChar);\rg_u32comRhead = (g_u32comRhead == (RXBUFSIZE - 1)) ? 0 : (g_u32comRhead + 1);\rg_u32comRbytes--;\r}\r}\r/* Handle transmission error */\rif(UART0-\u0026gt;FIFOSTS \u0026amp; (UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk | UART_FIFOSTS_RXOVIF_Msk))\r{\rUART0-\u0026gt;FIFOSTS = (UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk | UART_FIFOSTS_RXOVIF_Msk);\r}\r}\r/*---------------------------------------------------------------------------------------------------------*/\r/* UART Function Test */\r/*---------------------------------------------------------------------------------------------------------*/\rvoid UART_FunctionTest(void)\r{\rprintf(\u0026#34;+-----------------------------------------------------------+\\n\u0026#34;);\rprintf(\u0026#34;| UART Function Test |\\n\u0026#34;);\rprintf(\u0026#34;+-----------------------------------------------------------+\\n\u0026#34;);\rprintf(\u0026#34;| Description : |\\n\u0026#34;);\rprintf(\u0026#34;| The sample code will print input char on terminal |\\n\u0026#34;);\rprintf(\u0026#34;| Please enter any to start (Press \u0026#39;0\u0026#39; to exit) |\\n\u0026#34;);\rprintf(\u0026#34;+-----------------------------------------------------------+\\n\u0026#34;);\r/*\rUsing a RS232 cable to connect UART0 and PC.\rUART0 is set to debug port. UART0 is enable RDA interrupt.\rWhen inputting char to terminal screen, RDA interrupt will happen and\rUART0 will print the received char on screen.\r*/\r/* Enable UART RDA and THRE interrupt */\rNVIC_EnableIRQ(UART0_IRQn);\rUART_EnableInt(UART0, (UART_INTEN_RDAIEN_Msk | UART_INTEN_THREIEN_Msk));\rwhile(g_i32Wait);\r/* Disable UART RDA and THRE interrupt */\rNVIC_DisableIRQ(UART0_IRQn);\rUART_DisableInt(UART0, (UART_INTEN_RDAIEN_Msk | UART_INTEN_THREIEN_Msk));\rg_i32Wait = TRUE;\r} ","permalink":"https://weizongchen.github.io/blog/timer_delay/","tags":["Cortex M4"],"title":"Timer Delay 說明 (by M460)"},{"categories":["說明文件"],"contents":"在Keil IDE 的 Debug Mode 時 Memory window data 突然不實時更新了?\n下圖 右邊的 Memory2 本來會一直更新，但是沒有?\n只要在 View下的 Periodic Window Update 打開就好\n如下影片操作\n","permalink":"https://weizongchen.github.io/blog/keil_debug_memoryupdate/","tags":["Cortex M4"],"title":"Keil IDE Debug Mode Memory window data not update?"},{"categories":["說明文件"],"contents":"Keil IDE 在啟動 project 時，會自己上網下載 一堆不是新唐的pack\n下圖看到時趕緊關掉，不然他會一直download 不是新唐的東西。\n這邊選\u0026quot;是\u0026quot; 跳過這裡\n這個時候，Keil會跟你說沒有這個M460的 pack 包，你如果不安裝 ，compile 也會過，但是每次打開Keil 會就跳出來，滿煩的。\n去新唐的官網，下載Driver 就可以解決這個問題了。\n新唐Driver 位置\nNu-Link_Keil_Driver_V3.09.7380r\n準備安裝\n這裡如果你不懂，就按照指示預設安裝路徑。\n這裡會出現這個視窗，是因為我原本就已經安裝過這個Driver，裡面有M480 NUC505 \u0026hellip; 一堆 但是不包含M460的部分，所以按\u0026quot;是\u0026quot;，就會更新成有包含460的\n這裡步驟就是安裝pack(Nuvoton device family pack)了 一路按\u0026quot;是\u0026quot; 就可以了\n他會把Nuvoton的pack都安裝\n因為我使用新唐的開發版，上面有Nu-Link2-Me 的燒錄器，所以當然也安裝一下它的driver，你如果是 J-Link 、U-Link 、巴拉巴拉Link\u0026hellip;，要自己安裝他們的Driver喔。\n安裝\n再次打開Project 就不會有那些警告視窗拉~\n","permalink":"https://weizongchen.github.io/blog/keil_import_pack/","tags":["Cortex M4"],"title":"Keil IDE 在啟動 project 時，會自己上網下載 一堆不是新唐的pack"},{"categories":["說明文件"],"contents":"如果你不是商業使用 !\n如果你不是商業使用 !\n如果你不是商業使用 !\n很重要所以說三次! 所以如果你是個人評估使用\nARM 對這個 MDK-Community 說明\n簡單說就是支援 : All microcontrollers based on Arm Cortex®-M processors\n你給他E mail 它就給你licence\n把上面 LIC 填到下面\n","permalink":"https://weizongchen.github.io/blog/keil_ide_licence/","tags":["Cortex M4"],"title":"Keil IDE 16K Code size 限制?"},{"categories":["說明文件"],"contents":" 可以直接來這邊下載 https://www.nuvoton.com/tool-and-software/debugger-and-programmer/mass-production-tool/\nICP Tool 新唐燒錄器適用於新唐NuMicro®微控制器的大量生產階段。基於靈活的設定與直觀的操作，使用者可全面掌握量產流程。\n選擇你的series\n如果你電腦插著很多個NuLnk 可以選，點選Radio Button時，那個被指定的NuLnk會閃閃閃閃閃~\n如果你電腦灌過ICP 軟體了，跟這板子原本的ICP版本不匹配，你可以更新，也可以不更新，一般我都直接不更新，反正可以燒就好。\n因為我是要把板子上的APROM的 firmware拿出來存，可以照下圖的方式點選\n最後成功存取\nFile Data 要燒進去板子的FW版本\nOn board flash 板子上面的FW版本\nOffline Flash 在燒入除錯器裡面的版本\n怎麼去讀IC的 config ","permalink":"https://weizongchen.github.io/blog/icp_introduce/","tags":["Tool"],"title":"ICP 使用說明"},{"categories":["說明文件"],"contents":" User Manual https://www.nuvoton.com/export/resource-files/UM_NuMaker-ETM-M487_User_Manual_EN_Rev1.01.pdf\n通用 I/O (GPIO) 概述 M480 系列多達118 個通用I/O管腳和其他功能管腳共享，這取決於芯片的配置。 118個管腳分配在PA, PB, PC, PD, PE, PF, PG 和 PH這8個端口上。 PA, PB, PE和PG有16個管腳，PC，PD有15個管腳，PF，PH有12個管腳。每個管腳都是獨立的，都有相應的寄存器位來控制管腳功能模式與數據。\n1. 設定發電廠 (clock) 2. 設定 LED 的腳位 General Port 0~7 為 Low byte, 8~15 為 High byte 所以是Port H 的 0 1 2 是L，如下面黃色的標記\n設定 Port H 0 1 2 腳位為 output\n3. 設定 Button 的腳位 General Port 0~7 為 Low byte, 8~15 為 High byte 所以是Port B 的 15 是H , Port F 的 11 是H，如下面黃色的標記\n設定 Port B 15 和 Port F 11 腳位為 input\n4. 設定 UART0 的腳位 新唐大部分的M4 UART0 腳位是 PB12 RXD / PB13 TXD\n5. 設定中斷 這邊中斷就是用UART0 打印東西，和 toggle LED 的亮滅\n完整程式參考 /**************************************************************************//**\r* @file main.c\r* @version V3.00\r* @brief GPIO function for level1 training course\r*\r******************************************************************************/\r#include \u0026lt;stdio.h\u0026gt;\r#include \u0026#34;NuMicro.h\u0026#34;\r#define LED_R\tPH0\r#define LED_G\tPH1\r#define LED_B\tPH2\r#define LED_ON\t0\r#define LED_OFF\t1\rvolatile uint32_t sw1_int_cnt = 0;\rvolatile uint32_t sw2_int_cnt = 0;\rvoid SYS_Init(void)\r{\r/* Enable HXT clock (external XTAL 12MHz) */\rCLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);\r/* Wait for HXT clock ready */\rCLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);\r/* Enable LIRC clock */\rCLK_EnableXtalRC(CLK_PWRCTL_LIRCEN_Msk);\r/* Wait for LIRC clock ready */\rCLK_WaitClockReady(CLK_STATUS_LIRCSTB_Msk);\r/* Set core clock as PLL_CLOCK from PLL */\rCLK_SetCoreClock(FREQ_192MHZ);\r/* Set PCLK0/PCLK1 to HCLK/2 */\rCLK-\u0026gt;PCLKDIV = (CLK_PCLKDIV_PCLK0DIV2 | CLK_PCLKDIV_PCLK1DIV2);\r/* Enable module clock */\rCLK_EnableModuleClock(UART0_MODULE);\r/* Set module clock */\rCLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HXT, CLK_CLKDIV0_UART0(1));\r}\rvoid UART0_Init()\r{\r/* Set GPB multi-function pins to UART0 RXD and TXD */\rSYS-\u0026gt;GPB_MFPH = (SYS-\u0026gt;GPB_MFPH \u0026amp; ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk)) |\r(SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);\r/* Configure UART0 and set UART0 baud rate */\rUART_Open(UART0, 115200);\r}\rvoid LED_Init(void)\r{\r/* Set PH.0 ~ PH.2 to GPIO */\rSYS-\u0026gt;GPH_MFPL = (SYS-\u0026gt;GPH_MFPL \u0026amp; ~(SYS_GPH_MFPL_PH0MFP_Msk | SYS_GPH_MFPL_PH1MFP_Msk | SYS_GPH_MFPL_PH2MFP_Msk)) |\r(SYS_GPH_MFPL_PH0MFP_GPIO | SYS_GPH_MFPL_PH1MFP_GPIO | SYS_GPH_MFPL_PH2MFP_GPIO);\r/* Set PC.9 ~ PC.11 to GPIO output */\rGPIO_SetMode(PH, (BIT0 | BIT1 | BIT2), GPIO_MODE_OUTPUT);\r/* Let LED off after initialize */\rLED_R = LED_OFF;\rLED_G = LED_OFF;\rLED_B = LED_OFF;\r}\rvoid BTN_Init(void)\r{\r/************** SW2 ***************/\r/* Set PB.15 to GPIO */\rSYS-\u0026gt;GPG_MFPH = (SYS-\u0026gt;GPG_MFPH \u0026amp; ~(SYS_GPG_MFPH_PG15MFP_Msk)) | (SYS_GPG_MFPH_PG15MFP_GPIO);\r/* Set PB.15 to GPIO intput */\rGPIO_SetMode(PG, BIT15, GPIO_MODE_INPUT);\rGPIO_EnableInt(PG, 15, GPIO_INT_FALLING);\rNVIC_EnableIRQ(GPG_IRQn);\r/************** SW3 ***************/\r/* Set PF.11 to GPIO */\rSYS-\u0026gt;GPF_MFPH = (SYS-\u0026gt;GPF_MFPH \u0026amp; ~(SYS_GPF_MFPH_PF11MFP_Msk)) | (SYS_GPF_MFPH_PF11MFP_GPIO);\r/* Set PF.11 to GPIO intput */\rGPIO_SetMode(PF, BIT11, GPIO_MODE_INPUT);\rGPIO_EnableInt(PF, 11, GPIO_INT_FALLING);\rNVIC_EnableIRQ(GPF_IRQn);\r/* Set de-bounce function */\rGPIO_SET_DEBOUNCE_TIME(GPIO_DBCTL_DBCLKSRC_LIRC, GPIO_DBCTL_DBCLKSEL_512);\rGPIO_ENABLE_DEBOUNCE(PG, BIT15);\rGPIO_ENABLE_DEBOUNCE(PF, BIT11);\r}\rint main(void)\r{\ruint32_t sw1_cnt = 0, sw2_cnt = 0;\r/* Unlock protected registers */\rSYS_UnlockReg();\r/* Init System, peripheral clock and multi-function I/O */\rSYS_Init();\r/* Lock protected registers */\rSYS_LockReg();\r/* Init UART0 for printf */\rUART0_Init();\rprintf(\u0026#34;+---------------------------------------+\\n\u0026#34;);\rprintf(\u0026#34;| Level1 GPIO control Sample Code |\\n\u0026#34;);\rprintf(\u0026#34;+---------------------------------------+\\n\\n\u0026#34;);\r/* Init LED */\rLED_Init();\r/* Init BTN */\rBTN_Init();\rwhile(1) {\r/* Check if the SW1 is pressed */\rif (sw1_int_cnt != sw1_cnt) {\rsw1_cnt = sw1_int_cnt;\rprintf(\u0026#34;SW1 interrupt count: %d\\n\u0026#34;, sw1_cnt);\r}\r/* Check if the SW2 is pressed */\rif (sw2_int_cnt != sw2_cnt) {\rsw2_cnt = sw2_int_cnt;\rprintf(\u0026#34;SW2 interrupt count: %d\\n\u0026#34;, sw2_cnt);\r}\r}\r}\r//PG15\rvoid GPG_IRQHandler(void)\r{\rprintf(\u0026#34;+---------------------------------------+\\n\u0026#34;);\rprintf(\u0026#34;+------------Detect PG---------------+\\n\u0026#34;);\rprintf(\u0026#34;+---------------------------------------+\\n\u0026#34;);\r/* Check if PG.15 the interrupt occurred */\rif(GPIO_GET_INT_FLAG(PG, BIT15)) {\rLED_R ^= 1;\rsw1_int_cnt++;\r/* Clear PG.15 interrupt flag */\rGPIO_CLR_INT_FLAG(PG, BIT15);\r}else {\r/* Un-expected interrupt. Just clear all PB interrupts */\rPG-\u0026gt;INTSRC = PG-\u0026gt;INTSRC;\rprintf(\u0026#34;Un-expected interrupts.\\n\u0026#34;);\r}\r}\r//PF11\rvoid GPF_IRQHandler(void)\r{\rprintf(\u0026#34;+---------------------------------------+\\n\u0026#34;);\rprintf(\u0026#34;+------------Detect PF---------------+\\n\u0026#34;);\rprintf(\u0026#34;+---------------------------------------+\\n\u0026#34;);\r/* Check if PF.11 the interrupt occurred */\rif(GPIO_GET_INT_FLAG(PF, BIT11)) {\rLED_G ^= 1;\rsw2_int_cnt++;\r/* Clear PF.11 interrupt flag */\rGPIO_CLR_INT_FLAG(PF, BIT11);\r} else {\r/* Un-expected interrupt. Just clear all PB interrupts */\rPF-\u0026gt;INTSRC = PF-\u0026gt;INTSRC;\rprintf(\u0026#34;Un-expected interrupts.\\n\u0026#34;);\r}\r} M460 的控制LED範例 /*---------------------------------------------------------------------------------------------------------*/\r/* Main Function */\r/*---------------------------------------------------------------------------------------------------------*/\rint32_t main(void)\r{\r//Mode\r*(volatile unsigned int *)(0x400041C0) = 0x00001500;\r//value\r*(volatile unsigned int *)(0x400041C8) = 0x0000FF8F;\rwhile(1) {\rint i;\rfor(i = 0; i \u0026lt; 50000000; i++) {} //等1下\r*(volatile unsigned int *)(0x400041C8) = 0x00000000;\rfor(i = 0; i \u0026lt; 50000000; i++) {} //等1下\r*(volatile unsigned int *)(0x400041C8) = 0x00000070;\r}\r} *(volatile unsigned int *)(0x400041C0) = 0x00001500;\nRegister 位置\n0x40004000 + 0x1C0\nRegister的值\n0x 0000 1500\n000\u0026hellip;0 1500 如下圖\n*(volatile unsigned int *)(0x400041C8) = 0x00000070;\n0x1C8 是 PH_DOUT (port H out) 的控制\n70 如下圖所示 (0x00000070 全滅 0x00000000 全亮)\nint32_t main(void)\r{\r//Mode\r*(volatile unsigned int *)(0x400041C0) = 0x00001500;\rGPIO_SetMode(PH, BIT4, GPIO_MODE_OUTPUT);\r//value\r*(volatile unsigned int *)(0x400041C8) = 0x00000000;\rGPIO_SetMode(PH, BIT4, GPIO_MODE_OUTPUT);\rPH4 = 0;\rPH5 = 0;\rPH6 = 0;\rwhile(1) {\rint i;\rfor(i = 0; i \u0026lt; 50000000; i++) {} //等1百萬下\r// 全滅\r//*(volatile unsigned int *)(0x400041C8) = 0x00000000;\rPH4 = 1;\rPH5 = 1;\rPH6 = 1;\rfor(i = 0; i \u0026lt; 50000000; i++) {} //等1百萬下\r// 全亮\rPH4 = 0;\rPH5 = 0;\rPH6 = 0;\r}\r} M460 的控制Button範例 /**************************************************************************//**\r* @file main.c\r* @version V3.00\r* @brief Show the usage of GPIO interrupt function.\r*\r* @copyright SPDX-License-Identifier: Apache-2.0\r* @copyright Copyright (C) 2021 Nuvoton Technology Corp. All rights reserved.\r******************************************************************************/\r#include \u0026lt;stdio.h\u0026gt;\r#include \u0026#34;NuMicro.h\u0026#34;\rvoid GPH_IRQHandler(void);\rvoid SYS_Init(void);\rvoid UART0_Init(void);\r/**\r* @brief GPIO PH IRQ\r*\r* @param None\r*\r* @return None\r*\r* @details The PH default IRQ, declared in startup_m460.s.\r*/\rvoid GPH_IRQHandler(void)\r{\rvolatile uint32_t u32temp;\r/* To check if PH.0 interrupt occurred */\rif(GPIO_GET_INT_FLAG(PH, BIT0))\r{\rGPIO_CLR_INT_FLAG(PH, BIT0);\rprintf(\u0026#34;PH.0 INT occurred.\\n\u0026#34;);\r}\relse if(GPIO_GET_INT_FLAG(PH, BIT1))\r{\rGPIO_CLR_INT_FLAG(PH, BIT1);\rprintf(\u0026#34;PH.1 INT occurred.\\n\u0026#34;);\r}\relse\r{\r/* Un-expected interrupt. Just clear all PH interrupts */\ru32temp = PH-\u0026gt;INTSRC;\rPH-\u0026gt;INTSRC = u32temp;\rprintf(\u0026#34;Un-expected interrupts.\\n\u0026#34;);\r}\r}\rvoid SYS_Init(void)\r{\r/*---------------------------------------------------------------------------------------------------------*/\r/* Init System Clock */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Set PCLK0 and PCLK1 to HCLK/2 */\rCLK-\u0026gt;PCLKDIV = (CLK_PCLKDIV_APB0DIV_DIV2 | CLK_PCLKDIV_APB1DIV_DIV2);\r/* Set core clock to 200MHz */\rCLK_SetCoreClock(200000000);\r/* Enable all GPIO clock */\rCLK-\u0026gt;AHBCLK0 |= CLK_AHBCLK0_GPACKEN_Msk | CLK_AHBCLK0_GPBCKEN_Msk | CLK_AHBCLK0_GPCCKEN_Msk | CLK_AHBCLK0_GPDCKEN_Msk |\rCLK_AHBCLK0_GPECKEN_Msk | CLK_AHBCLK0_GPFCKEN_Msk | CLK_AHBCLK0_GPGCKEN_Msk | CLK_AHBCLK0_GPHCKEN_Msk;\rCLK-\u0026gt;AHBCLK1 |= CLK_AHBCLK1_GPICKEN_Msk | CLK_AHBCLK1_GPJCKEN_Msk;\r/* Enable UART0 module clock */\rCLK_EnableModuleClock(UART0_MODULE);\r/* Select UART0 module clock source as HIRC and UART0 module clock divider as 1 */\rCLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HIRC, CLK_CLKDIV0_UART0(1));\r/*---------------------------------------------------------------------------------------------------------*/\r/* Init I/O Multi-function */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Set multi-function pins for UART0 RXD and TXD */\rSET_UART0_RXD_PB12();\rSET_UART0_TXD_PB13();\r}\rvoid UART0_Init(void)\r{\r/*---------------------------------------------------------------------------------------------------------*/\r/* Init UART */\r/*---------------------------------------------------------------------------------------------------------*/\r/* Reset UART0 */\rSYS_ResetModule(UART0_RST);\r/* Configure UART0 and set UART0 baud rate */\rUART_Open(UART0, 115200);\r}\r/*---------------------------------------------------------------------------------------------------------*/\r/* Main Function */\r/*---------------------------------------------------------------------------------------------------------*/\rint32_t main(void)\r{\r/* Unlock protected registers */\rSYS_UnlockReg();\r/* Init System, peripheral clock and multi-function I/O */\rSYS_Init();\r/* Lock protected registers */\rSYS_LockReg();\r/* Init UART0 for printf */\rUART0_Init();\rprintf(\u0026#34;\\n\\nCPU @ %d Hz\\n\u0026#34;, SystemCoreClock);\rprintf(\u0026#34;+------------------------------------------------+\\n\u0026#34;);\rprintf(\u0026#34;| GPIO PH.0 and PH.1 Interrupt Sample Code |\\n\u0026#34;);\rprintf(\u0026#34;+------------------------------------------------+\\n\\n\u0026#34;);\r/*-----------------------------------------------------------------------------------------------------*/\r/* GPIO Interrupt Function Test */\r/*-----------------------------------------------------------------------------------------------------*/\rprintf(\u0026#34;PH.0 and PH.1 are used to test interrupt ......\\n\u0026#34;);\r/* Configure PH.0 as Input mode and enable interrupt by rising edge trigger */\rGPIO_SetMode(PH, BIT0, GPIO_MODE_INPUT);\rGPIO_EnableInt(PH, 0, GPIO_INT_RISING);\rNVIC_EnableIRQ(GPH_IRQn);\r/* Configure PH.1 as Quasi-bidirection mode and enable interrupt by falling edge trigger */\rGPIO_SetMode(PH, BIT1, GPIO_MODE_QUASI);\rGPIO_EnableInt(PH, 1, GPIO_INT_FALLING);\rNVIC_EnableIRQ(GPH_IRQn);\r/* Enable interrupt de-bounce function and select de-bounce sampling cycle time is 1024 clocks of LIRC clock */\rGPIO_SET_DEBOUNCE_TIME(PH, GPIO_DBCTL_DBCLKSRC_LIRC, GPIO_DBCTL_DBCLKSEL_1024);\rGPIO_SET_DEBOUNCE_TIME(PH, GPIO_DBCTL_DBCLKSRC_LIRC, GPIO_DBCTL_DBCLKSEL_1024);\rGPIO_ENABLE_DEBOUNCE(PH, BIT0);\rGPIO_ENABLE_DEBOUNCE(PH, BIT1);\r/* Waiting for interrupts */\rwhile(1);\r} ","permalink":"https://weizongchen.github.io/blog/gpio_introduce/","tags":["Cortex M4"],"title":"GPIO 說明"},{"categories":["安裝步驟文件"],"contents":"Description Enable the Remoteproc device driver in the Linux kernel.\n$ bitbake linux-ma35d1 -c menuconfig Device Drivers ---\u0026gt;\rRemoteproc drivers ---\u0026gt;\r[*] Support for Remote Processor subsystem\r\u0026lt;*\u0026gt; MA35D1 remoteproc support \u0026lt;Save\u0026gt; and \u0026lt;Exit\u0026gt; Description Modify the device tree node setting of remoteproc in the Linux kernel.\nLINUX_KERENL_PATH/arch/arm64/boot/dts/nuvoton/ma35d1.dtsi Description Compile the Linux kernel.\n$ bitbake linux-ma35d1 -C compile Description Modify the device tree node setting of SSPCC in the TF-A. 怎麼知道是I2S0_SUBM的?\nDescription Modify the device tree node setting of SSPCC in the TF-A. 怎麼知道是這4根pin角的?\nDescription Compile the TF-A.\n$ bitbake tf-a-ma35d1 -C compile Description Build-up Image. Qt 版本:\nbitbake nvt-image-qt5 -c cleanall \u0026amp;\u0026amp; bitbake nvt-image-qt5 Minimal 版本:\n$ bitbake core-image-minimal –c cleanall \u0026amp;\u0026amp; bitbake core-image-minimal Description Burn-in Image into SD card. 燒入SD卡\n$ sudo dd if=nvt-image-qt5-evb-ma35d1-xxxxx.rootfs.sdcard of=/dev/sdb 延展SD的size\rsudo ./ma35d1_resize.sh /dev/sdb 1 apply 把 M4 的.axf 放到SD卡的 /lib/firmware 中\nNote: The following step copy all of RTP (M4) sample codes in the M4_BSP into Filesystem. You can chose the sample code you want to use or replace with the firmware you developed. 執行 M4 axf 的指令\necho -n /lib/firmware \u0026gt; /sys/module/firmware_class/parameters/path\recho -n I2S_Codec_PDMA.elf \u0026gt; /sys/class/remoteproc/remoteproc0/firmware\recho start \u0026gt; /sys/class/remoteproc/remoteproc0/state\recho stop \u0026gt; /sys/class/remoteproc/remoteproc0/state Remoteproc - Keil IDE 設定\nNu-link 的DAP 要設定1\nPS:原本我們開發板的NuLink 是 0 ，MA35D1的要改1 ","permalink":"https://weizongchen.github.io/blog/ma35d1_rtp/","tags":["MA35D1"],"title":"MA35D1 M4 使用設定"},{"categories":["安裝步驟文件"],"contents":"MA35D16A887C (BGA312) MCP package with DDR3L (256 MB)\n7-inch TFT LCD (1024x600) with touch daughter board\neMMC memory device daughter board\nSPI-NAND flash W25N02JWZEIF (256MB)\nNAND flash W29N01HVS1NA (128MB)\n2 x Giga Ethernet\n2 x High Speed USB\n2 x Camera Capture (CMOS sensor) header connectors\n1 x SIM Card slot\n2 x UART, 2 x RS485, 2 x CAN-FD, 8 x EADC channels\n基本安裝設定 Yocto 項目至少需要 150G 存儲\n在使用 Yocto 項目之前必須安裝必要的包\n$ sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib \\\rbuild-essential chrpath socat cpio python python3 python3-pip python3-pexpect \\\rxz-utils debianutils iputils-ping libsdl1.2-dev xterm curl Update existing list of packages\n$ sudo apt-get update Install a few prerequisite packages which let apt use packages over HTTPS\n$ sudo apt install apt-transport-https ca-certificates curl software-properties-common Add Docker’s official GPG key for the official Docker repository to your system\n$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add Set up the stable repository, add the Docker repository to APT sources\n$ sudo add-apt-repository \u0026#34;deb [arch=amd64] https://download.docker.com/linux/ubuntu focal stable\u0026#34; Update the package database with the Docker packages from the newly added repo\n$ sudo apt-get update Install Docker\n$ sudo apt-get install docker-ce docker-ce-cli containerd.io Download the Docker Script for MA35D1\n$ git clone https://github.com/OpenNuvoton/MA35D1_Docker_Script.git Enter docker-yocto folder, setup docker image, and select folder to be share\n$ ./build.sh It may take one hour to get 710 files.\rPlease enter absolute path for shared folders(eg:/home/\u0026lt;user name\u0026gt;) : Enter docker image, and your command line head will be like nuvoton@a24d9e06abe3:~$\n$ ./join.sh\rnua3500_nuvoton\rnuvoton@a24d9e06abe3:~$ Create a folder name yocto under /share\nnuvoton@a24d9e06abe3:~/share$ mkdir yocto The first time you use repo, you need to set up the GIT environment\nnuvoton@a24d9e06abe3:~/share/yocto$ git config --global user.email \u0026#34;test@test.test.test\u0026#34;\rnuvoton@a24d9e06abe3:~/share/yocto$ git config --global user.name \u0026#34;test“\rnuvoton@a24d9e06abe3:~/share/yocto$ git config --global http.sslverify false Go to /share/yocto to setup repo path\nnuvoton@a24d9e06abe3:~/share/yocto$ repo init -u https://github.com/OpenNuvoton/MA35D1_Yocto-v3.1.3.git -m meta-ma35d1/base/ma35d1.xml Download the yocto project\nnuvoton@a24d9e06abe3:~/share/yocto$ repo sync Build Image by Yocto Setup building configuration. The DISTRO option we usually use nvt-ma35d1-directfb\nEVB :\n~/yocto$ DISTRO=nvt-ma35d1-directfb MACHINE=ma35d1-evb source sources/init-build-env build SOM :\n~/yocto$ DISTRO=nvt-ma35d1-directfb MACHINE=numaker-som-ma35d16a81 source sources/init-build-env build MACHINE 目前有 SOM 板 或 IOT 板，後面ma35d16a81是 板號，所以客戶可以做他自己的板子，用自己得板號。\nMACHINE=numaker-som-ma35d16a81\nMACHINE=numaker-iot-ma35d16f70\ntest chip SOM :\n~/yocto$ DISTRO=nvt-ma35d1-directfb MACHINE=ma35d1-tc-som source sources/init-build-env build Choose what Image you want to build\nImage 包含Qt的版本 (建議)\nbitbake nvt-image-qt5 小 Image 版本\nbitbake core-image-minimal Copy the image to SD $ sudo dd if=nvt-image-qt5-evb-ma35d1-xxxxx.rootfs.sdcard of=/dev/sdb Fast Application Development Make a toolchain installer\n$ bitbake nvt-image-qt5 -c populate_sdk\r(This may take about 1 hour ) Go to the following path and execute the shell file\n~build/tmp-glibc/deploy/sdk $ ./oecore-x86_x64-aarch64-toolcahin-5.5-dunfell.sh Add toolchain to environment variables\n$ source /usr/local/oecore-x86_64/environment-setup-aarch64-poky-linux Create the source code file for this example: helloworld.c\n#include \u0026lt;stdio.h\u0026gt;\rint main() {\r// printf() displays the string inside console\rprintf(“Hello, World!\\n”);\rreturn 0;\r} Compile it\n$ $CC helloworld.c -o helloworld ","permalink":"https://weizongchen.github.io/blog/ma35d1_install_method/","tags":["MA35D1"],"title":"MA35D1 Yocto 安裝說明"},{"categories":["說明文件"],"contents":" 要找這個Register\n問這個PDBIASEN bit 找不到\u0026hellip;..\nCLK-\u0026gt;LDOCTL |= CLK_LDOCTL_PDBIASEN_Msk;\nClock, LDO control Rigister, PDBIASEN 這個 bit\nbit 18\n忘記在哪一版本TRM 有找到這個register\n右邊表格˙(1) (2) 沒有賣了，所以只是給過去參考，目前就是看(3) 就好~\nCore Coupled Memory Mode (CCM Mode)\nCCM Mode 是 SRAM 跟 SPI Flash 的關係，SPI Flash可以把SRAM當作catch來使用，\nCCMEN 打開 就是一般SRAM，不是catch\nWhen user sets CCMEN(SPIM_CTL1[2]) to 1, the operation mode of cache memory will be core coupled memory mode (CCM mode). In CCM mode, the cache function of SPI Flash controller is disabled by hardware automatically, and MCU can access this core coupled memory as general SRAM. When user sets CCMEN(SPIM_CTL1[2]) to 0 and MCU accesses CCM address range, SPI Flash controller will generate AHB error response to MCU.\n當用戶設置CCMEN(SPIM_CTL1[2])為1時，緩存存儲器操作模式會轉變成內核耦合存儲器模式(CCM模 式)。在CCM模式下，SPI flash控制器的緩存功能會被硬件自動禁用，MCU訪問內核耦合存儲器就像是 SRAM一樣。當用戶設置CCMEN(SPIM_CTL1[2])為0時MCU訪問CCM地址範圍，SPI flash控制器將會 產生AHB錯誤給MCU\n","permalink":"https://weizongchen.github.io/blog/question/","tags":null,"title":"自己的問題筆記"},{"categories":["安裝步驟文件"],"contents":"系統環境 Windows 10 VS 2019 OpenCV 4.5.5 選擇 Windows 版本的OpenCV download下來 解壓縮到指定資料夾 可以在C 根目錄建一個 OpenCV 資料夾，在OpenCV資料夾下再建一個OpenCV4.5.5資料夾，並解押到這裡面\n整理檔案位置，將需要的檔案拿出來就好 因為opencv資料夾的大小很大，可以刪除。如空間夠大可以留下來，以備不時之需。\nbin 資料夾說明 opencv 3 版本之後，只需要opencv_world455.dll就可以了，opencv_world455d.dll 多一個d是指 debug版本的意思。\n設定環境變數 建立一個空的C++專案 建立一個空的C++專案 在這裡應該有solution 和 project 的分別，我們要在solution的位置新增一個專案 建立屬性管理員 Property Manager 方便每次專案可以套用同一個屬性，比如哪天出了opencv新的版本，可以直接套用新的版本的opencv或使用更舊版本的opencv 去view打開屬姓管理員，預設是沒有顯示的。 使用x64的Release版本\n建一個有意義的名子，給x64、opencv版本是455、Release的版本使用的property 已產生此版本的屬性，待會就用這個屬性設定opencv的變數\n使用 Property Manager 設定OpenCV的環境 記得因為我們是使用 Release x64 版本的屬性所以上面要改一下\n基本上打到第2層，就會有提示字出現之後，就表示設定成功了，設定一下起始專案。\n寫一個簡單的程式測試一下 opencv 的設定 // loadimg.cpp : 此檔案包含 \u0026#39;main\u0026#39; 函式。程式會於該處開始執行及結束執行。\r//\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;opencv2/core/core.hpp\u0026gt;\r#include \u0026lt;opencv2/highgui/highgui.hpp\u0026gt;\rusing namespace std;\rusing namespace cv;\rint main()\r{\rMat img;\rimg = imread(\u0026#34;C:\\\\Users\\\\b51ak\\\\Pictures\\\\promotion.png\u0026#34;);\rnamedWindow(\u0026#34;figure 1\u0026#34;, WINDOW_AUTOSIZE);\rimshow(\u0026#34;figure 1\u0026#34;, img);\rstd::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\\n\u0026#34;;\rwaitKey(0);\rreturn 0;\r} ","permalink":"https://weizongchen.github.io/blog/opencv_env/","tags":["OpenCV"],"title":"OpenCV 環境安裝"}]