[{"categories":["說明文件"],"contents":" 可以直接來這邊下載 https://www.nuvoton.com/tool-and-software/debugger-and-programmer/mass-production-tool/\nICP Tool 新唐燒錄器適用於新唐NuMicro®微控制器的大量生產階段。基於靈活的設定與直觀的操作，使用者可全面掌握量產流程。\n選擇你的series\n如果你電腦插著很多個NuLnk 可以選，點選Radio Button時，那個被指定的NuLnk會閃閃閃閃閃~\n如果你電腦灌過ICP 軟體了，跟這板子原本的ICP版本不匹配，你可以更新，也可以不更新，一般我都直接不更新，反正可以燒就好。\n因為我是要把板子上的APROM的 firmware拿出來存，可以照下圖的方式點選\n最後成功存取\n","permalink":"https://weizongchen.github.io/about/icp_introduce/","tags":["Tool"],"title":"ICP 使用說明"},{"categories":["說明文件"],"contents":" User Manual https://www.nuvoton.com/export/resource-files/UM_NuMaker-ETM-M487_User_Manual_EN_Rev1.01.pdf\n通用 I/O (GPIO) 概述 M480 系列多達118 個通用I/O管腳和其他功能管腳共享，這取決於芯片的配置。 118個管腳分配在PA, PB, PC, PD, PE, PF, PG 和 PH這8個端口上。 PA, PB, PE和PG有16個管腳，PC，PD有15個管腳，PF，PH有12個管腳。每個管腳都是獨立的，都有相應的寄存器位來控制管腳功能模式與數據。\n1. 設定發電廠 (clock) 2. 設定 LED 的腳位 General Port 0~7 為 Low byte, 8~15 為 High byte 所以是Port H 的 0 1 2 是L，如下面黃色的標記\n設定 Port H 0 1 2 腳位為 output\n3. 設定 Button 的腳位 General Port 0~7 為 Low byte, 8~15 為 High byte 所以是Port B 的 15 是H , Port F 的 11 是H，如下面黃色的標記\n設定 Port B 15 和 Port F 11 腳位為 input\n4. 設定 UART0 的腳位 新唐大部分的M4 UART0 腳位是 PB12 RXD / PB13 TXD\n5. 設定中斷 這邊中斷就是用UART0 打印東西，和 toggle LED 的亮滅\n完整程式參考 /**************************************************************************//**\r* @file main.c\r* @version V3.00\r* @brief GPIO function for level1 training course\r*\r******************************************************************************/\r#include \u0026lt;stdio.h\u0026gt;\r#include \u0026#34;NuMicro.h\u0026#34;\r#define LED_R\tPH0\r#define LED_G\tPH1\r#define LED_B\tPH2\r#define LED_ON\t0\r#define LED_OFF\t1\rvolatile uint32_t sw1_int_cnt = 0;\rvolatile uint32_t sw2_int_cnt = 0;\rvoid SYS_Init(void)\r{\r/* Enable HXT clock (external XTAL 12MHz) */\rCLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);\r/* Wait for HXT clock ready */\rCLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);\r/* Enable LIRC clock */\rCLK_EnableXtalRC(CLK_PWRCTL_LIRCEN_Msk);\r/* Wait for LIRC clock ready */\rCLK_WaitClockReady(CLK_STATUS_LIRCSTB_Msk);\r/* Set core clock as PLL_CLOCK from PLL */\rCLK_SetCoreClock(FREQ_192MHZ);\r/* Set PCLK0/PCLK1 to HCLK/2 */\rCLK-\u0026gt;PCLKDIV = (CLK_PCLKDIV_PCLK0DIV2 | CLK_PCLKDIV_PCLK1DIV2);\r/* Enable module clock */\rCLK_EnableModuleClock(UART0_MODULE);\r/* Set module clock */\rCLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_HXT, CLK_CLKDIV0_UART0(1));\r}\rvoid UART0_Init()\r{\r/* Set GPB multi-function pins to UART0 RXD and TXD */\rSYS-\u0026gt;GPB_MFPH = (SYS-\u0026gt;GPB_MFPH \u0026amp; ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk)) |\r(SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);\r/* Configure UART0 and set UART0 baud rate */\rUART_Open(UART0, 115200);\r}\rvoid LED_Init(void)\r{\r/* Set PH.0 ~ PH.2 to GPIO */\rSYS-\u0026gt;GPH_MFPL = (SYS-\u0026gt;GPH_MFPL \u0026amp; ~(SYS_GPH_MFPL_PH0MFP_Msk | SYS_GPH_MFPL_PH1MFP_Msk | SYS_GPH_MFPL_PH2MFP_Msk)) |\r(SYS_GPH_MFPL_PH0MFP_GPIO | SYS_GPH_MFPL_PH1MFP_GPIO | SYS_GPH_MFPL_PH2MFP_GPIO);\r/* Set PC.9 ~ PC.11 to GPIO output */\rGPIO_SetMode(PH, (BIT0 | BIT1 | BIT2), GPIO_MODE_OUTPUT);\r/* Let LED off after initialize */\rLED_R = LED_OFF;\rLED_G = LED_OFF;\rLED_B = LED_OFF;\r}\rvoid BTN_Init(void)\r{\r/************** SW2 ***************/\r/* Set PB.15 to GPIO */\rSYS-\u0026gt;GPG_MFPH = (SYS-\u0026gt;GPG_MFPH \u0026amp; ~(SYS_GPG_MFPH_PG15MFP_Msk)) | (SYS_GPG_MFPH_PG15MFP_GPIO);\r/* Set PB.15 to GPIO intput */\rGPIO_SetMode(PG, BIT15, GPIO_MODE_INPUT);\rGPIO_EnableInt(PG, 15, GPIO_INT_FALLING);\rNVIC_EnableIRQ(GPG_IRQn);\r/************** SW3 ***************/\r/* Set PF.11 to GPIO */\rSYS-\u0026gt;GPF_MFPH = (SYS-\u0026gt;GPF_MFPH \u0026amp; ~(SYS_GPF_MFPH_PF11MFP_Msk)) | (SYS_GPF_MFPH_PF11MFP_GPIO);\r/* Set PF.11 to GPIO intput */\rGPIO_SetMode(PF, BIT11, GPIO_MODE_INPUT);\rGPIO_EnableInt(PF, 11, GPIO_INT_FALLING);\rNVIC_EnableIRQ(GPF_IRQn);\r/* Set de-bounce function */\rGPIO_SET_DEBOUNCE_TIME(GPIO_DBCTL_DBCLKSRC_LIRC, GPIO_DBCTL_DBCLKSEL_512);\rGPIO_ENABLE_DEBOUNCE(PG, BIT15);\rGPIO_ENABLE_DEBOUNCE(PF, BIT11);\r}\rint main(void)\r{\ruint32_t sw1_cnt = 0, sw2_cnt = 0;\r/* Unlock protected registers */\rSYS_UnlockReg();\r/* Init System, peripheral clock and multi-function I/O */\rSYS_Init();\r/* Lock protected registers */\rSYS_LockReg();\r/* Init UART0 for printf */\rUART0_Init();\rprintf(\u0026#34;+---------------------------------------+\\n\u0026#34;);\rprintf(\u0026#34;| Level1 GPIO control Sample Code |\\n\u0026#34;);\rprintf(\u0026#34;+---------------------------------------+\\n\\n\u0026#34;);\r/* Init LED */\rLED_Init();\r/* Init BTN */\rBTN_Init();\rwhile(1) {\r/* Check if the SW1 is pressed */\rif (sw1_int_cnt != sw1_cnt) {\rsw1_cnt = sw1_int_cnt;\rprintf(\u0026#34;SW1 interrupt count: %d\\n\u0026#34;, sw1_cnt);\r}\r/* Check if the SW2 is pressed */\rif (sw2_int_cnt != sw2_cnt) {\rsw2_cnt = sw2_int_cnt;\rprintf(\u0026#34;SW2 interrupt count: %d\\n\u0026#34;, sw2_cnt);\r}\r}\r}\r//PG15\rvoid GPG_IRQHandler(void)\r{\rprintf(\u0026#34;+---------------------------------------+\\n\u0026#34;);\rprintf(\u0026#34;+------------Detect PG---------------+\\n\u0026#34;);\rprintf(\u0026#34;+---------------------------------------+\\n\u0026#34;);\r/* Check if PG.15 the interrupt occurred */\rif(GPIO_GET_INT_FLAG(PG, BIT15)) {\rLED_R ^= 1;\rsw1_int_cnt++;\r/* Clear PG.15 interrupt flag */\rGPIO_CLR_INT_FLAG(PG, BIT15);\r}else {\r/* Un-expected interrupt. Just clear all PB interrupts */\rPG-\u0026gt;INTSRC = PG-\u0026gt;INTSRC;\rprintf(\u0026#34;Un-expected interrupts.\\n\u0026#34;);\r}\r}\r//PF11\rvoid GPF_IRQHandler(void)\r{\rprintf(\u0026#34;+---------------------------------------+\\n\u0026#34;);\rprintf(\u0026#34;+------------Detect PF---------------+\\n\u0026#34;);\rprintf(\u0026#34;+---------------------------------------+\\n\u0026#34;);\r/* Check if PF.11 the interrupt occurred */\rif(GPIO_GET_INT_FLAG(PF, BIT11)) {\rLED_G ^= 1;\rsw2_int_cnt++;\r/* Clear PF.11 interrupt flag */\rGPIO_CLR_INT_FLAG(PF, BIT11);\r} else {\r/* Un-expected interrupt. Just clear all PB interrupts */\rPF-\u0026gt;INTSRC = PF-\u0026gt;INTSRC;\rprintf(\u0026#34;Un-expected interrupts.\\n\u0026#34;);\r}\r} ","permalink":"https://weizongchen.github.io/about/gpio_introduce/","tags":["Cortex M4"],"title":"GPIO 說明"},{"categories":["說明文件"],"contents":" 要找這個Register\n問這個PDBIASEN bit 找不到\u0026hellip;..\nCLK-\u0026gt;LDOCTL |= CLK_LDOCTL_PDBIASEN_Msk;\nClock, LDO control Rigister, PDBIASEN 這個 bit\nbit 18\n忘記在哪一版本TRM 有找到這個register\n右邊表格˙(1) (2) 沒有賣了，所以只是給過去參考，目前就是看(3) 就好~\nCore Coupled Memory Mode (CCM Mode)\nCCM Mode 是 SRAM 跟 SPI Flash 的關係，SPI Flash可以把SRAM當作catch來使用，\nCCMEN 打開 就是一般SRAM，不是catch\nWhen user sets CCMEN(SPIM_CTL1[2]) to 1, the operation mode of cache memory will be core coupled memory mode (CCM mode). In CCM mode, the cache function of SPI Flash controller is disabled by hardware automatically, and MCU can access this core coupled memory as general SRAM. When user sets CCMEN(SPIM_CTL1[2]) to 0 and MCU accesses CCM address range, SPI Flash controller will generate AHB error response to MCU.\n當用戶設置CCMEN(SPIM_CTL1[2])為1時，緩存存儲器操作模式會轉變成內核耦合存儲器模式(CCM模 式)。在CCM模式下，SPI flash控制器的緩存功能會被硬件自動禁用，MCU訪問內核耦合存儲器就像是 SRAM一樣。當用戶設置CCMEN(SPIM_CTL1[2])為0時MCU訪問CCM地址範圍，SPI flash控制器將會 產生AHB錯誤給MCU\n","permalink":"https://weizongchen.github.io/blog/question/","tags":null,"title":"自己的問題筆記"},{"categories":["安裝步驟文件"],"contents":"系統環境 Windows 10 VS 2019 OpenCV 4.5.5 選擇 Windows 版本的OpenCV download下來 解壓縮到指定資料夾 可以在C 根目錄建一個 OpenCV 資料夾，在OpenCV資料夾下再建一個OpenCV4.5.5資料夾，並解押到這裡面\n整理檔案位置，將需要的檔案拿出來就好 因為opencv資料夾的大小很大，可以刪除。如空間夠大可以留下來，以備不時之需。\nbin 資料夾說明 opencv 3 版本之後，只需要opencv_world455.dll就可以了，opencv_world455d.dll 多一個d是指 debug版本的意思。\n設定環境變數 建立一個空的C++專案 建立一個空的C++專案 在這裡應該有solution 和 project 的分別，我們要在solution的位置新增一個專案 建立屬性管理員 Property Manager 方便每次專案可以套用同一個屬性，比如哪天出了opencv新的版本，可以直接套用新的版本的opencv或使用更舊版本的opencv 去view打開屬姓管理員，預設是沒有顯示的。 使用x64的Release版本\n建一個有意義的名子，給x64、opencv版本是455、Release的版本使用的property 已產生此版本的屬性，待會就用這個屬性設定opencv的變數\n使用 Property Manager 設定OpenCV的環境 記得因為我們是使用 Release x64 版本的屬性所以上面要改一下\n基本上打到第2層，就會有提示字出現之後，就表示設定成功了，設定一下起始專案。\n寫一個簡單的程式測試一下 opencv 的設定 // loadimg.cpp : 此檔案包含 \u0026#39;main\u0026#39; 函式。程式會於該處開始執行及結束執行。\r//\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;opencv2/core/core.hpp\u0026gt;\r#include \u0026lt;opencv2/highgui/highgui.hpp\u0026gt;\rusing namespace std;\rusing namespace cv;\rint main()\r{\rMat img;\rimg = imread(\u0026#34;C:\\\\Users\\\\b51ak\\\\Pictures\\\\promotion.png\u0026#34;);\rnamedWindow(\u0026#34;figure 1\u0026#34;, WINDOW_AUTOSIZE);\rimshow(\u0026#34;figure 1\u0026#34;, img);\rstd::cout \u0026lt;\u0026lt; \u0026#34;Hello World!\\n\u0026#34;;\rwaitKey(0);\rreturn 0;\r} ","permalink":"https://weizongchen.github.io/blog/opencv_env/","tags":["OpenCV"],"title":"OpenCV 環境安裝"}]